#+title: Doom Emacs Configuration
#+property: header-args:emacs-lisp
#+property: header-args:elisp :results replace :exports code
#+property: header-args:shell :tangle "setup.sh"
#+property: header-args :tangle no :results silent :eval no-export
#+startup: fold

* Introduction

Customising an editor can be very rewarding ... until you have to leave it.
For years I have been looking for ways to avoid this pain.
Then I discovered [[https://github.com/cknadler/vim-anywhere][vim-anywhere]], and found that it had an Emacs companion,
[[https://github.com/zachcurry/emacs-anywhere][emacs-anywhere]]. To me, this looked most attractive.

Separately, online I have seen the following statement enough times I think it's a catchphrase
#+begin_quote
Redditor 1: I just discovered this thing, isn't it cool. \\
Redditor 2: Oh, there's an Emacs mode for that.
#+end_quote

This was enough for me to install Emacs, but I soon learned there are [[https://github.com/remacs/remacs#why-emacs][far more
compelling reasons]] to keep using it.

I tried out the =spacemacs= distribution a bit, but it wasn't quite to my liking.
Then I heard about =doom emacs= and thought I may as well give that a try.
TLDR; it's great.

Now I've discovered the wonders of literate programming, and am becoming more
settled by the day. This is both my config, and a cautionary tale (just replace
"Linux" with "Emacs" in the comic below).

[[xkcd:456]]

** Why Emacs?

Emacs is [[https://www.eigenbahn.com/2020/01/12/emacs-is-no-editor][not a text editor]], this is a common misnomer. It is far more apt to
describe Emacs as /a Lisp machine providing a generic user-centric text
manipulation environment/. That's quite a mouthful.
In simpler terms one can think of Emacs as a platform for text-related
applications. It's a vague and generic definition because Emacs itself is
generic.

Good with text. How far does that go? A lot further than one initially thinks:
+ [[https://orgmode.org/][Task planning]]
+ [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html][File management]]
+ [[https://github.com/akermu/emacs-libvterm][Terminal emulation]]
+ [[https://www.djcbsoftware.nl/code/mu/mu4e.html][Email client]]
+ [[https://www.gnu.org/software/tramp/][Remote server tool]]
+ [[https://magit.vc/][Git frontend]]
+ Web [[https://github.com/pashky/restclient.el][client]]/[[https://github.com/skeeto/emacs-web-server][server]]
+ and more...

Ideally, one may use Emacs as /the/ interface to perform =input → transform →
output= cycles, i.e. form a bridge between the human mind and information
manipulation.

*** The enveloping editor

Emacs allows one to do more in one place than any other application. Why is this
good?
+ Enables one to complete tasks with a consistent, standard set of keybindings,
  GUI and editing methods --- learn once, use everywhere
+ Reduced context-switching
+ Compressing the stages of a project --- a more centralised workflow can progress
  with greater ease
+ Integration between tasks previously relegated to different applications, but
  with a common subject --- e.g. linking to an email in a to-do list

Emacs can be thought of as a platform within which various elements of your
workflow may settle, with the potential for rich integrations between them --- a
/life/ IDE if you will.

Today, many aspects of daily computer usage are split between different
applications which act like islands, but this often doesn't mirror how we
/actually use/ our computers. Emacs, if one goes down the rabbit hole, can give
users the power to bridge this gap.

#+name: emacs-platform
#+begin_src dot :cmd circo :file misc/emacs-platform.svg :exports none
digraph {
    graph [bgcolor="transparent"];
    node  [shape="underline" penwidth="2" style="rounded,filled" fillcolor="#efefef" color="#c9c9c9" fontcolor="#000000" fontname="overpass"];
    edge  [arrowhead=none color="#aaaaaa" penwidth="1.2"]
    // nodes
    "Task Managment" [color="#2ec27e"]
    "Email" [color="#1c71d8"]
    "Office suite" [color="#813d9c"]
    "Code editor" [color="#f5c211"]
    "Git client" [color="#e66100"]
    // "News feed" [color="#c01c28"]
    // "Personal Knowledge Base" [color="#986a44"]

    "Task Managment" -> "Email"
    "Task Managment" -> "Office suite"
    "Task Managment" -> "Code editor"
    "Task Managment" -> "Git client"
    // "Task Managment" -> "News feed"
    // "Task Managment" -> "Personal Knowledge Base"

    "Email" -> "Office suite"
    "Email" -> "Code editor"
    "Email" -> "Git client"
    // "Email" -> "Personal Knowledge Base"

    "Office suite" -> "Code editor"
    "Office suite" -> "Git client"
    // "Office suite" -> "News feed"
    // "Office suite" -> "Personal Knowledge Base"

    "Code editor" -> "Git client"

    // "News feed" -> "Personal Knowledge Base"
}
#+end_src

#+caption: Some sample workflow integrations that can be used within Emacs
#+attr_html: :class invertible :alt Graph of possible Emacs task integrations :style max-width:min(24em,100%)
#+attr_latex: :width 0.55\linewidth
[[file:misc/emacs-platform.svg]]

*** Some notably unique features

+ Recursive editing
+ Completely introspectable, with pervasive docstrings
+ Mutable environment, which can be incrementally modified
+ Functionality without applications
+ Client-server separation allows for a daemon, giving near-instant perceived
  startup time.

*** Issues

+ Emacs has irritating quirks
+ Some aspects are showing their age (naming conventions, APIs)
+ Emacs is ([[https://www.gnu.org/software/emacs/manual/html_node/elisp/Threads.html][mostly]]) single-threaded, meaning that when something holds that
  thread up the whole application freezes
+ A few other nuisances

*** Teach a man to fish...

#+begin_quote
Give a man a fish, and you feed him for a day. Teach a man to fish, and you feed
him for a lifetime. --- Anne Isabella
#+end_quote

Most popular editors have a simple and pretty [[https://code.visualstudio.com/docs/getstarted/settings][settings interface]], filled with
check-boxes, selects, and the occasional text-box. This makes it easy for the
user to pick between common desirable behaviours. To me this is now like /giving
a man a fish/.

What if you want one of those 'check-box' settings to be only on in certain
conditions? Some editors have workspace settings, but that requires you to
manually set the value for /every single instance/. Urgh, [[https://github.com/microsoft/vscode/issues/93153][what]] [[https://github.com/microsoft/vscode/issues/93628][a]] [[https://github.com/microsoft/vscode/issues/5595][pain]].

What if you could set the value of that 'check-box' setting to be the result of
an arbitrary expression evaluated for each file? This is where an editor like
Emacs comes in.
Configuration for Emacs isn't a list of settings in JSON etc. it's *an executable
program which modifies the behaviour of the editor to suit your liking*.
This is 'teaching a man to fish'.

Emacs is built in the same language you configure it in (Emacs [[https://en.wikipedia.org/wiki/Lisp_(programming_language)][Lisp]], or [[https://www.gnu.org/software/emacs/manual/html_node/eintr/][elisp]]).
It comes with a broad array of useful functions for text-editing, and Doom adds
a few handy little convenience functions.

Want to add a keybinding to delete the previous line? It's as easy as
#+name: Keybinding to delete the previous line
#+begin_src emacs-lisp :tangle no
(map! "C-d"
      (cmd! (previous-line)
            (kill-line)
            (forward-line)))
#+end_src

How about another example, say you want to be presented with a list of currently
open /buffers/ (think files, almost) when you split the window. It's as simple as
#+name: Prompt for buffer after split
#+begin_src emacs-lisp :tangle no
(defadvice! prompt-for-buffer (&rest _)
  :after 'window-split (switch-to-buffer))
#+end_src

Want to test it out? You don't need to save and restart, you can just /evaluate
the expression/ within your current Emacs instance and try it immediately! This
editor is, after all, a Lisp interpreter.

Want to tweak the behaviour? Just re-evaluate your new version --- it's a
super-tight iteration loop.

** Editor comparison

[[xkcd:378]]

Over the years I have tried out (spent at least a year using as my primary
editor) the following applications
- Python IDLE
- Komodo Edit
- Brackets
- VSCode
- and now, Emacs

I have attempted to quantify aspects of my impressions of them below.

#+plot: transpose:yes type:radar min:0 max:4 ticks:4 file:"misc/editor-comparison.svg"
| Editor      | Extensibility | Ecosystem | Ease of Use | Comfort | Completion | Performance |
|-------------+---------------+-----------+-------------+---------+------------+-------------|
| IDLE        |             1 |         1 |           3 |       1 |          1 |           2 |
| VSCode      |             3 |         3 |           4 |     3.5 |          4 |           3 |
| Brackets    |           2.5 |         2 |           3 |       3 |        2.5 |           2 |
| Emacs       |             4 |         4 |           2 |       4 |        3.5 |           3 |
| Komodo Edit |             2 |         1 |           3 |       2 |          2 |           2 |

#+attr_html: :class invertible :alt Radar chart comparing my thoughts on a few editors.
#+attr_latex: :options inkscapelatex=false
[[file:misc/editor-comparison.svg]]

** Notes for the unwary adventurer

If you like the look of this, that's marvellous, and I'm really happy that I've
made something which you may find interesting, however:
#+begin_warning
This config is /insidious/. Copying the whole thing blindly can easily lead to
undesired effects. I recommend copying chunks instead.
#+end_warning

If you are so bold as to wish to steal bits of my config (or if I upgrade and
wonder why things aren't working), here's a list of sections which rely on
external setup (i.e. outside of this config).

+ dictionary :: I've downloaded a custom [[http://app.aspell.net/create][SCOWL]] dictionary, which I use in [[*Ispell][ispell]].
  If this causes issues, just delete the src_elisp{(setq ispell-dictionary ...)}
  bit.

There are also a number of files I may tangle to /other than/
={init,config,package}.el=. The complete list (excluding confpkg generated files)
is as follows:

#+begin_src emacs-lisp :results value list replace :exports results :eval yes
(mapcar
 (lambda (path)
   (format "=%s="
           (replace-regexp-in-string
            (regexp-quote (getenv "HOME")) "~"
            (expand-file-name path default-directory))))
 (sort
  (cl-remove-if
   (lambda (path)
     (or (member path '("yes" "no"))
         (string-match-p "^/tmp" path)))
   (cl-delete-duplicates
    (org-element-map (org-element-parse-buffer)
        'src-block
      (lambda (src)
        (let ((dest (alist-get :tangle
                               (org-babel-parse-header-arguments
                                (org-element-property :parameters src) t))))
          (if (and (stringp dest) (string-match-p "^(if" dest))
              (car (cl-set-difference
                    (mapcar #'eval (seq-drop (read dest) 2))
                    '("yes" "no")
                    :test #'equal))
            dest))))
    :test #'equal))
  #'string<))
#+end_src

Oh, did I mention that I started this config when I didn't know any =elisp=, and
this whole thing is a hack job? If you can suggest any improvements, please do
so, no matter how much criticism you include I'll appreciate it :)

[[xkcd:1513]]

*** Extra Requirements

The lovely ~doom doctor~ is good at diagnosing most missing things, but here are a
few extras.
+ A [[https://www.tug.org/texlive/][LaTeX Compiler]] is required for the mathematics rendering performed in [[#org][Org]],
  and by [[*CalcTeX][CalcTeX]].
+ I use the [[https://overpassfont.org/][Overpass]] font as a go-to sans serif.
  It's used as my ~doom-variable-pitch-font~ and in the graph generated
  by [[*Roam][Roam]].
  I have chosen it because it possesses a few characteristics I consider
  desirable, namely:
  - A clean, and legible style. Highway-style fonts tend to be designed to be
    clear at a glance, and work well with a thicker weight, and this is inspired
    by /Highway Gothic/.
  - It's slightly quirky. Look at the diagonal cut on stems for example.
    Helvetica is a masterful design, but I like a bit more pizzazz now and then.
+ A few LSP servers. Take a look at [[file:init.el][init.el]] to see which modules have the ~+lsp~ flag.

** Current Issues
*** Magit push in daemon

Quite often trying to push to a remote in the Emacs daemon produces as error like this:
#+begin_src fundamental
128 git … push -v origin refs/heads/master\:refs/heads/master
Pushing to git@github.com:tecosaur/emacs-config.git

fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.
#+end_src

*** Unread emails doesn't work across Emacs instances

It would be nice if it did, so that I could have the Emacs-daemon hold the
active mu4e session, but still get that information. In this case I'd want to
change the action to open the Emacs daemon, but it should be possible.

This would probably involve hooking into the daemon's modeline update function
to write to a temporary file, and having a file watcher started in other Emacs
instances, in a similar manner to [[*Rebuild mail index while using mu4e][Rebuild mail index while using mu4e]].

* Rudimentary configuration
** Confpkg
*** Motivation

Previously, all of my configuration was directly tangled into =config.el=. This
/almost/ satisfies my use. Occasionally though, I'd want to apply or extract a
/specific bit/ of my config in an elisp script, such as some of my Org-export
customisations. This is a hassle, either loading my entire config (of which 90%
simply complicates the state), or manually copying the relevant code in pieces,
one source block at a time (just a different kind of hassle). While I'd like to
think my config is "greater than the sum of its parts", much of it can be safely
clumped into self-contained packets of functionality.

One afternoon I thought "wouldn't it be nice if I could just load a few of those
self-contained chunks of my config", then I started thinking about how I could
have that /and/ =config.el=. This is the result.

*** Design

It's already natural to organise blocks of config under sections, and we can use
=:noweb-ref= with a =header-args:emacs-lisp= property to direct all child source
blocks into a single parent. We could have two parents, one tangling to
=subconf/config-X.el= and the other to =config.el=, however this will duplicate
any evaluations required to generate the content, which isn't great
(particularly for things which take a moment, like checking for LaTeX
packages). Instead we can /just/ write to the =subconf/*= files and then at the
end of tangling extract their contents into =config.el=.

#+begin_src dot :file misc/confpkg.svg :results file graphics
digraph {
    graph [bgcolor="transparent"];
    node  [shape="underline" penwidth="2" style="rounded,filled" fillcolor="#efefef" color="#c9c9c9" fontcolor="#000000" fontname="Alegreya Sans"];
    edge  [color="#aaaaaa" penwidth="1.2" fontname="Alegreya Sans"]
    rankdir="LR"
    "config.org" [color="#4db5bd"]
    "config.el" [color="#e69055"]
    node[color="#a991f1"]
    "subconf/config-magit.el"
    "subconf/config-org.el"
    "subconf/config-?.el"
    node[color="#51afef"]
    "config.org" -> "Magit#src1" -> "subconf/config-magit.el" -> "config.el"
    "config.org" -> "Magit#src2" -> "subconf/config-magit.el"
    "config.org" -> "Org#src1" -> "subconf/config-org.el" -> "config.el"
    "config.org" -> "Org#src2" -> "subconf/config-org.el"
    "config.org" -> "Org#..." -> "subconf/config-org.el"
    "config.org" -> "(etc.)#..." -> "subconf/config-?.el" -> "config.el"
}
#+end_src

#+caption: Flow of code information from the literate config into the generated files.
#+attr_html: :class invertible :alt DAG showing code block info go to config-*.el files then config.el
#+attr_latex: :width 0.7\linewidth
#+RESULTS:
[[file:misc/confpkg.svg]]

To set this up within each section, instead of manually repeating a common form
we can generate the form and supply the relevant section properties via a babel
call keyword, like so:

#+begin_src org
,* Subject

,#+call: confpkg("subject")

,#+begin_src emacs-lisp
;; Code that configures the subject...
,#+end_src
#+end_src

This isn't entirely straightforward, but with some mild abuse of noweb and babel
we can make it work!

*** Preparation

This approach is built around =#+call= invocations that affect the tangling.
Unfortunately for this use-case, babel call keywords are not executed on tangle.
Tangled noweb blocks /are/ however, and so we can fudge the behaviour we want by
tangling a noweb block to a temp file, with a noweb block that executes babel
calls in the buffer.

#+name: confpkg-prepare
#+begin_src emacs-lisp :noweb no-export
(condition-case nil
    (progn
      (message "Intitialising confpkg")
      <<bootstrap>>
      (org-fold-core-ignore-fragility-checks
        (org-babel-map-executables nil
          (when (eq (org-element-type (org-element-context)) 'babel-call)
            (org-babel-lob-execute-maybe)))))
  (quit (revert-buffer t t t)))
#+end_src

See the [[Bootstrap]] section for an explanation of the =<<bootstrap>>= noweb reference.

#+header: :tangle (expand-file-name (make-temp-name "emacs-org-babel-excuses/confpkg-prepare-") temporary-file-directory)
#+begin_src emacs-lisp :noweb no-export :mkdirp yes :export-embed no
<<confpkg-prepare()>>
#+end_src

*** Setup

Before generating the template with babel, we want to keep track of:
+ How many config groups are created
+ Information about each config group

To do this we can simply create two variables. Due to temp-buffer shenanigans,
we'll have to use global variables here.

Then we need to set up the two final phases of this process:
+ Creating =config.el=
+ Cleaning up the superfluous generated content

To trigger the final phases we'll add a hook to ~org-babel-post-tangle-hook~. Once
again, it would be preferred if this was done locally, but it needs to be
global. To avoid this causing headaches down the line we'll make sure when
implementing the hook function to have it remove itself from the hook when
executed.

#+name: confpkg-setup
#+begin_src emacs-lisp :results silent :noweb no-export
(setq confpkg--num 0
      confpkg--list nil)

<<confpkg-dependency-analysis>>
<<confpkg-strip-package-statements>>
<<confpkg-create-config>>
(defun confpkg-cleanup ()
 <<confpkg-cleanup>>
  )
<<confpkg-finaliser>>

<<confpkg-clear-old-files>>

(add-hook 'org-babel-tangle-finished-hook #'confpkg-tangle-finalise)
#+end_src

To avoid generating cruft, it would also be good to get rid of old tangled
config files at the start.

#+name: confpkg-clear-old-files
#+begin_src emacs-lisp
(make-directory "subconf" t)
(dolist (conf-file (directory-files "subconf" t "config-.*\\.el"))
  (delete-file conf-file))
#+end_src

Now to have this take effect, we can just use a babel call keyword. Thanks to
the preparation step this will be executed during tangling.

#+call: confpkg-setup[:results none]()

*** Package generation

Now we actually implement the =confpkg= babel function. We could just direct the
output into the =subconf/config-X.el= file without any extra steps, but why not be
a bit fancier and make it more like a package.

To do this, we'll have =confpkg= load a template and then fill it in using
~format-spec~. To make sure this is actually used, we'll call ~org-set-property~ to
modify the parent heading, and register the config group with the variables we
created earlier.

#+name: confpkg
#+begin_src elisp :var name="" needs="" after="" pre="" prefix="config-" via="copy" :results silent raw :noweb no-export
;; Babel block for use with #+call
;; Arguments:
;;  - name, the name of the config sub-package
;;  - needs, (when non-empty) required system executable(s)
;;  - after, required features
;;  - pre, a noweb reference to code that should be executed eagerly,
;;    and not deferred via after. The code is not included in the
;;    generated .el file and should only be used in dire situations.
;;  - prefix, the package prefix ("config-" by default)
;;  - via, how this configuration should be included in config.el,
;;    the current options are:
;;    + "copy", copy the configuration lisp
;;    + "require", insert a require statement
;;    + "none", do not do anything to load this configuration.
;;      This only makes sense when configuration is either being
;;      temporarily disabled or loaded indirectly/elsewhere.
(when (or (string-empty-p needs)
          (cl-every #'executable-find (delq nil (split-string needs ","))))
  (let* ((name (if (string-empty-p name)
                   (save-excursion
                     (and (org-back-to-heading-or-point-min t)
                          (substring-no-properties
                           (org-element-interpret-data
                            (org-element-property :title (org-element-at-point))))))
                 name))
         (after
          (cond
           ((string-empty-p after) nil)
           ((string-match-p "\\`[^()]+\\'" after)
            (intern after)) ; Single feature.
           (t after)))
         (pre (and (not (string-empty-p pre)) pre))
         (confpkg-name
          (concat prefix (replace-regexp-in-string
                          "[^a-z-]" "-" (downcase name))))
         (confpkg-file (expand-file-name (concat confpkg-name ".el")
                                         "subconf")))
    (unless (file-exists-p confpkg-file)
      (make-empty-file confpkg-file t))
    (cl-incf confpkg--num)
    (org-set-property
     "header-args:emacs-lisp"
     (format ":tangle no :noweb-ref %s" confpkg-name))
    (push (list :name name
                :package confpkg-name
                :file confpkg-file
                :after after
                :pre pre
                :via (intern via)
                :package-statements nil)
          confpkg--list)
    (format-spec
     "#+begin_src emacs-lisp :tangle %f :mkdirp yes :noweb no-export :noweb-ref none :comments no
<<confpkg-template>>
,#+end_src"
     `((?n . ,confpkg--num)
       (?p . ,confpkg-name)
       (?f . ,confpkg-file)
       (?Y . ,(format-time-string "%Y"))
       (?B . ,(format-time-string "%B"))
       (?m . ,(format-time-string "%m"))
       (?d . ,(format-time-string "%d"))
       (?M . ,(format-time-string "%M"))
       (?S . ,(format-time-string "%S"))))))
#+end_src

Now all that's needed is a template to be used.

#+name: confpkg-template
#+begin_src emacs-lisp :eval no
;;; %p.el --- Generated package (no.%n) from my config -*- lexical-binding: t; -*-
;;
;; Copyright (C) %Y TEC
;;
;; Author: TEC <https://git.tecosaur.net/tec>
;; Maintainer: TEC <contact@tecosaur.net>
;; Created: %B %d, %Y
;; Modified: %B %d, %Y
;; Version: %Y.%m.%d
;; Homepage: https://git.tecosaur.net/tec/emacs-config
;; Package-Requires: ((emacs \"27.1\"))
;;
;; This file is not part of GNU Emacs.
;;
;;; Commentary:
;;
;;  Generated package (no.%n) from my config.
;;
;;  This is liable to have unstated dependencies, and reply on other bits of
;;  state from other configuration blocks. Only use this if you know /exactly/
;;  what you are doing.
;;
;;  This may function nicely as a bit of self-contained functionality, or it
;;  might be a horrid mix of functionalities and state.
;;
;;  Hopefully, in future static analysis will allow this to become more
;;  properly package-like.
;;
;;; Code:

<<%p>>

(provide '%p)
;;; %p.el ends here
#+end_src

This currently makes the included content look much more package-like that in
truly is. However, I hope that some static analysis in future will allow for
dependency information to be collected and included.

Lastly, should there be an issue or interruption, it's possible that the
modifications from =#+call: confpkg= may persist. If I've been good with my
committing, resolving this should be as simple as reverting unstaged changes.
So... back in reality, it would be nice to have a way to clean up =confpkg=
residue.

#+name: confpkg-cleanup
#+begin_src emacs-lisp :results none
(org-fold-core-ignore-fragility-checks
  (org-babel-map-executables nil
    (when (and (eq (org-element-type (org-element-context)) 'babel-call)
               (equal (org-element-property :call (org-element-context)) "confpkg"))
      (org-babel-remove-result)
      (org-entry-delete nil "header-args:emacs-lisp"))))
#+end_src

*** Identify cross-package dependencies
:PROPERTIES:
:header-args:emacs-lisp: :noweb-ref confpkg-dependency-analysis
:END:

At a basic level, we can search for regexp expressions indicating the definition
of functions or variables and search for their usage.

#+begin_src emacs-lisp
(defun confpkg--rough-extract-definitions (file)
  (with-temp-buffer
    (insert-file-contents file)
    (goto-char (point-min))
    (let (symbols)
      (while (re-search-forward
              (rx line-start (* (any ?\s ?\t)) "("
                  (or "defun" "defmacro" "defsubst" "defgeneric" "defalias" "defvar" "defcustom" "defface" "deftheme"
                      "cl-defun" "cl-defmacro" "cl-defsubst" "cl-defmethod" "cl-defstruct" "cl-defgeneric" "cl-deftype")
                  (+ (any ?\s ?\t))
                  (group (+ (any "A-Z" "a-z" "0-9"
                                 ?+ ?- ?* ?/ ?_ ?~ ?! ?@ ?$ ?% ?^ ?& ?= ?: ?< ?> ?{ ?})))
                  (or blank ?\n))
              nil t)
        (push (match-string 1) symbols))
      symbols)))
#+end_src

Continuing our rough regexp approach, we can construct a similar function to
look for uses of symbols.

#+begin_src emacs-lisp
(defun confpkg--rough-uses-p (file symbols)
  (with-temp-buffer
    (insert-file-contents file)
    (let ((symbols (copy-sequence symbols)) uses-p)
      (while symbols
        (goto-char (point-min))
        (if (re-search-forward (rx word-start (literal (car symbols)) word-end) nil t)
            (setq uses-p t symbols nil)
          (setq symbols (cdr symbols))))
      uses-p)))
#+end_src

Now we can put these two functions together to annotate ~confpkg--list~ with their
(confpkg) dependencies.

#+begin_src emacs-lisp
(defun confpkg-annotate-list-dependencies ()
  (dolist (confpkg confpkg--list)
    (plist-put confpkg :defines
               (confpkg--rough-extract-definitions
                (plist-get confpkg :file))))
  (dolist (confpkg confpkg--list)
    (let ((after (plist-get confpkg :after))
          requires)
      (dolist (other-confpkg confpkg--list)
        (when (and (not (eq other-confpkg confpkg))
                   (confpkg--rough-uses-p (plist-get confpkg :file)
                                          (plist-get other-confpkg :defines)))
          (push (plist-get other-confpkg :package) requires)))
      (when (and after (symbolp after))
        (push after requires))
      (plist-put confpkg :requires requires))))
#+end_src

Finally, we can use this information to edit the confpkg files to add the
necessary ~require~ statements.

#+begin_src emacs-lisp
(defun confpkg-write-dependencies ()
  (dolist (confpkg confpkg--list)
    (when (plist-get confpkg :requires)
      (with-temp-buffer
        (setq buffer-file-name (plist-get confpkg :file))
        (insert-file-contents buffer-file-name)
        (re-search-forward "^;;; Code:\n")
        (insert "\n")
        (dolist (req (plist-get confpkg :requires))
          (insert (format "(require '%s)\n" req)))
        (write-region nil nil buffer-file-name)
        (set-buffer-modified-p nil)))))
#+end_src

*** Commenting out ~package!~ statements

It's easy enough to set ~package!~ statements to tangle to =packages.el=, however
with our noweb ref approach they will /also/ go to the config files. This could be
viewed as a problem, but I actually think it's rather nice to have the package
information with the config. So, we can look for an immediate ~package!~ statement
and simply comment it out. As a bonus, we can also then record which packages
are needed for each block of config.

#+name: confpkg-strip-package-statements
#+begin_src emacs-lisp
(defun confpkg-comment-out-package-statements ()
  (dolist (confpkg confpkg--list)
    (with-temp-buffer
      (setq buffer-file-name (plist-get confpkg :file))
      (insert-file-contents buffer-file-name)
      (goto-char (point-min))
      (while (re-search-forward "^;;; Code:\n[[:space:]\n]*(\\(package!\\|unpin!\\)[[:space:]\n]+\\([^[:space:]]+\\)\\b" nil t)
        (plist-put confpkg :package-statements
                   (nconc (plist-get confpkg :package-statements)
                          (list (match-string 2))))
        (let* ((start (progn (beginning-of-line) (point)))
               (end (progn (forward-sexp 1)
                           (if (looking-at "[\t ]*;.*")
                               (line-end-position)
                             (point))))
               (contents (buffer-substring start end))
               paste-start paste-end
               (comment-start ";")
               (comment-padding "   ")
               (comment-end ""))
          (delete-region start (1+ end))
          (re-search-backward "^;;; Code:")
          (beginning-of-line)
          (insert ";;  Package statement:\n")
          (setq paste-start (point))
          (insert contents)
          (setq paste-end (point))
          (insert  "\n;;\n")
          (comment-region paste-start paste-end 2)))
      (when (buffer-modified-p)
        (write-region nil nil buffer-file-name)
        (set-buffer-modified-p nil)))))
#+end_src

*** Creating the config file

After all the subconfig files have been tangled, we need to collect their
content and put them together into =config.el=. For this, all that's needed is a
function to go through the registered config groups and put their content in a
tempbuffer. We can call this with the finalising step.

#+name: confpkg-create-config
#+begin_src emacs-lisp
(defun confpkg-create-config ()
  (let ((revert-without-query '("config\\.el"))
        (keywords (org-collect-keywords '("AUTHOR" "EMAIL")))
        (original-buffer (current-buffer)))
    (with-temp-buffer
      (insert
       (format ";;; config.el -*- lexical-binding: t; -*-

;; SPDX-FileCopyrightText: © 2020-%s %s <%s>
;; SPDX-License-Identifier: MIT

;; Generated at %s from the literate configuration.

(add-to-list 'load-path %S)\n"
               (format-time-string "%Y")
               (cadr (assoc "AUTHOR" keywords))
               (cadr (assoc "EMAIL" keywords))
               (format-time-string "%FT%T%z")
               (replace-regexp-in-string
                (regexp-quote (getenv "HOME")) "~"
                (expand-file-name "subconf/"))))
      (mapc
       (lambda (confpkg)
         (insert
          (if (eq 'none (plist-get confpkg :via))
              (format "\n;;; %s intentionally omitted.\n" (plist-get confpkg :name))
            (with-temp-buffer
              (cond
               ((eq 'copy (plist-get confpkg :via))
                (insert-file-contents (plist-get confpkg :file))
                (goto-char (point-min))
                (narrow-to-region
                 (re-search-forward "^;;; Code:\n+")
                 (progn
                   (goto-char (point-max))
                   (re-search-backward (format "[^\n\t ][\n\t ]*\n[\t ]*(provide '%s)" (plist-get confpkg :package)))
                   (match-end 0))))
               ((eq 'require (plist-get confpkg :via))
                (insert (format "(require '%s)\n" (plist-get confpkg :package))))
               (t (insert (format "(warn \"%s confpkg :via has unrecognised value: %S\" %S %S)"
                                  (plist-get confpkg :name) (plist-get confpkg :via)))))
              (goto-char (point-min))
              (insert "\n;;:------------------------"
                      "\n;;; " (plist-get confpkg :name)
                      "\n;;:------------------------\n\n")
              (when (plist-get confpkg :defines)
                (insert ";; This block defines "
                        (mapconcat
                         (lambda (d) (format "`%s'" d))
                         (plist-get confpkg :defines)
                         ", ")
                        ".")
                (when (re-search-backward "\\([^, ]+\\), \\([^, ]+\\), \\([^, ]+\\).\\="
                                          (line-beginning-position) t)
                  (replace-match "\\1, \\2, and \\3."))
                (when (re-search-backward "\\([^, ]+\\), \\([^, ]+\\).\\="
                                          (line-beginning-position) t)
                  (replace-match "\\1 and \\2."))
                (insert "\n\n")
                (forward-line -2)
                (setq-local comment-start ";")
                (fill-comment-paragraph)
                (forward-paragraph 1)
                (forward-line 1))
              (if (equal (plist-get confpkg :package) "config-confpkg-timings")
                  (progn
                    (goto-char (point-max))
                    (insert "\n\n\
(confpkg-create-record 'doom-pre-config (float-time (time-subtract (current-time) before-init-time)))
(confpkg-start-record 'config)
(confpkg-create-record 'config-defered 0.0 'config)
(confpkg-create-record 'set-hooks 0.0 'config-defered)
(confpkg-create-record 'load-hooks 0.0 'config-defered)
(confpkg-create-record 'requires 0.0 'root)\n"))
                (let ((after (plist-get confpkg :after))
                      (pre (and (plist-get confpkg :pre)
                                (org-babel-expand-noweb-references
                                 (list "emacs-lisp"
                                       (format "<<%s>>" (plist-get confpkg :pre))
                                       '((:noweb . "yes")
                                         (:comments . "none")))
                                 original-buffer)))
                      (name (replace-regexp-in-string
                             "config--?" ""
                             (plist-get confpkg :package))))
                  (if after
                      (insert (format "(confpkg-with-record '%S\n"
                                      (list (concat "hook: " name) 'set-hooks))
                              (if pre
                                  (concat ";; Begin pre\n" pre "\n;; End pre\n")
                                "")
                              (format (if (symbolp after) ; If single feature.
                                          "  (with-eval-after-load '%s\n"
                                        "  (after! %s\n")
                                      after))
                    (when pre
                      (insert "\n;; Begin pre (unnecesary since after is unused)\n"
                              pre
                              "\n;; End pre\n")))
                  (insert
                   (format "(confpkg-with-record '%S\n"
                           (list (concat "load: " name)
                                 (if after 'load-hooks 'config)))))
                (goto-char (point-max))
                (when (string-match-p ";" (thing-at-point 'line))
                  (insert "\n"))
                (insert ")")
                (when (plist-get confpkg :after)
                  (insert "))"))
                (insert "\n"))
              (buffer-string)))))
       (let ((confpkg-timings ;; Ensure timings is put first.
              (cl-some (lambda (p) (and (equal (plist-get p :package) "config-confpkg-timings") p))
                       confpkg--list)))
         (append (list confpkg-timings)
                 (nreverse (remove confpkg-timings confpkg--list)))))
      (insert "\n(confpkg-finish-record 'config)\n\n;;; config.el ends here")
      (write-region nil nil "config.el" nil :silent))))
#+end_src

Applying lexical binding to the config file is good for a number of reasons,
among which it's (slightly) faster than dynamic binding (see [[https://nullprogram.com/blog/2016/12/22/][this blog post]] for
more info).

*** Quieter output

All the babel evaluation here ends up being quite noisy (along with a few other
things during tangle), let's see if we can change that.

#+name: confpkg-quieter-output
#+begin_src emacs-lisp
(when noninteractive
  (unless (fboundp 'doom-shut-up-a)
    (defun doom-shut-up-a (fn &rest args)
      (let ((standard-output #'ignore)
            (inhibit-message t))
        (apply fn args))))
  (advice-add 'org-babel-expand-body:emacs-lisp :around #'doom-shut-up-a)
  ;; Quiet some other annoying messages
  (advice-add 'sh-set-shell :around #'doom-shut-up-a)
  (advice-add 'rng-what-schema :around #'doom-shut-up-a)
  (advice-add 'python-indent-guess-indent-offset :around #'doom-shut-up-a))
#+end_src

#+call: confpkg-quieter-output()

*** Reporting load time information

#+call: confpkg("Confpkg timings")

When generating the config we added a form to collect load-time information.

#+begin_src emacs-lisp
(defvar confpkg-load-time-tree (list (list 'root)))
(defvar confpkg-record-branch (list 'root))
(defvar confpkg-record-num 0)
#+end_src

It would be good to process ~confpkg-load-times~ at the end to make it more
useful, and provide a function to display load time information from it. This is
to aid in identification of confpkgs that take particularly long to load, and
thus would benefit from some attention.

To extract the per-confpkg load times, we can just take the difference in
~(float-time)~ and exclude the first entry.

#+begin_src emacs-lisp
(defun confpkg-create-record (name elapsed &optional parent enclosing)
  (let ((parent (assoc (or parent (car confpkg-record-branch))
                       confpkg-load-time-tree))
        (record (cons name (list (list 'self
                                       :name (format "%s" name)
                                       :num (cl-incf confpkg-record-num)
                                       :elapsed elapsed
                                       :enclosing enclosing)))))
    (push record confpkg-load-time-tree)
    (push record (cdr parent))
    record))

(defun confpkg-start-record (name &optional parent)
  (let ((record (confpkg-create-record name 0.0e+NaN parent t)))
    (plist-put (cdadr record) :start (float-time))
    (push name confpkg-record-branch)
    record))

(defun confpkg-finish-record (name)
  (let ((self-record (cdar (last (cdr (assoc name confpkg-load-time-tree))))))
    (plist-put self-record :elapsed
               (- (float-time) (plist-get self-record :start) 0.0))
    (unless (equal (car confpkg-record-branch) name)
      (message "Warning: Confpkg timing record expected to finish %S, instead found %S. %S"
               name (car confpkg-record-branch) confpkg-record-branch))
    (setq confpkg-record-branch (cdr confpkg-record-branch))))
#+end_src

A convenience macro could be nice to have.

#+begin_src emacs-lisp
(defmacro confpkg-with-record (name &rest body)
  "Create a time record around BODY.
The record must have a NAME."
  (declare (indent 1))
  (let ((name-val (make-symbol "name-val"))
        (record-spec (make-symbol "record-spec")))
    `(let* ((,name-val ,name)
            (,record-spec (if (consp ,name-val) ,name-val (list ,name-val))))
       (apply #'confpkg-start-record ,record-spec)
       (unwind-protect
           (progn ,@body)
         (confpkg-finish-record (car ,record-spec))))))
#+end_src

It would also be nice to collect some other load-time-related information.

#+begin_src emacs-lisp
(defadvice! +require--log-timing-a (orig-fn feature &optional filename noerror)
  :around #'require
  (if (or (featurep feature)
          (eq feature 'cus-start) ; HACK Why!?!
          (assoc (format "require: %s" feature) confpkg-load-time-tree))
      (funcall orig-fn feature filename noerror)
    (confpkg-with-record (list (format "require: %s" feature)
                               (and (eq (car confpkg-record-branch) 'root)
                                    'requires))
      (funcall orig-fn feature filename noerror))))
#+end_src

At last, we'll go to some pains to make a nice result tabulation function.

I will readily admit that this function is absolutely horrible. I just spent an
evening adding to it till it worked then stopped touching it. Maybe in the
future I'll go back to it and try to clean up the implementation.

#+begin_src emacs-lisp
(defun confpkg-timings-report (&optional sort-p node)
  "Display a report on load-time information.
Supply SORT-P (or the universal argument) to sort the results.
NODE defaults to the root node."
  (interactive
   (list (and current-prefix-arg t)))
  (let ((buf (get-buffer-create "*Confpkg Load Time Report*"))
        (depth 0)
        num-pad name-pad max-time max-total-time max-depth)
    (cl-labels
        ((sort-records-by-time
          (record)
          (let ((self (assoc 'self record)))
            (append (list self)
                    (sort (nreverse (remove self (cdr record)))
                          (lambda (a b)
                            (> (or (plist-get (alist-get 'self a) :total) 0.0)
                               (or (plist-get (alist-get 'self b) :total) 0.0)))))))
         (print-record
          (record)
          (cond
           ((eq (car record) 'self)
            (insert
             (propertize
              (string-pad (number-to-string (plist-get (cdr record) :num)) num-pad)
              'face 'font-lock-keyword-face)
             " "
             (propertize
              (apply #'concat
                     (make-list (1- depth) "• "))
              'face 'font-lock-comment-face)
             (string-pad (format "%s" (plist-get (cdr record) :name)) name-pad)
             (make-string (* (- max-depth depth) 2) ?\s)
             (propertize
              (format "%.4fs" (plist-get (cdr record) :elapsed))
              'face
              (list :foreground
                    (doom-blend 'orange 'green
                                (/ (plist-get (cdr record) :elapsed) max-time))))
             (if (= (plist-get (cdr record) :elapsed)
                    (plist-get (cdr record) :total))
                 ""
               (concat "   (Σ="
                       (propertize
                        (format "%.3fs" (plist-get (cdr record) :total))
                        'face
                        (list :foreground
                              (doom-blend 'orange 'green
                                          (/ (plist-get (cdr record) :total) max-total-time))))
                       ")"))
             "\n"))
           (t
            (cl-incf depth)
            (mapc
             #'print-record
             (if sort-p
                 (sort-records-by-time record)
               (reverse (cdr record))))
            (cl-decf depth))))
         (flatten-records
          (records)
          (if (eq (car records) 'self)
              (list records)
            (mapcan
             #'flatten-records
             (reverse (cdr records)))))
         (tree-depth
          (records &optional depth)
          (if (eq (car records) 'self)
              (or depth 0)
            (1+ (cl-reduce #'max (cdr records) :key #'tree-depth))))
         (mapreduceprop
          (list map reduce prop)
          (cl-reduce
           reduce list
           :key
           (lambda (p) (funcall map (plist-get (cdr p) prop)))))
         (elaborate-timings
          (record)
          (if (eq (car record) 'self)
              (plist-get (cdr record) :elapsed)
            (let ((total (cl-reduce #'+ (cdr record)
                                    :key #'elaborate-timings))
                  (self (cdr (assoc 'self record))))
              (if (plist-get self :enclosing)
                  (prog1
                      (plist-get self :elapsed)
                    (plist-put self :total (plist-get self :elapsed))
                    (plist-put self :elapsed
                               (- (* 2 (plist-get self :elapsed)) total)))
                (plist-put self :total total)
                total))))
         (elaborated-timings
          (record)
          (let ((record (copy-tree record)))
            (elaborate-timings record)
            record)))
      (let* ((tree
              (elaborated-timings
               (append '(root)
                       (copy-tree
                        (alist-get (or node 'root)
                                   confpkg-load-time-tree
                                   nil nil #'equal))
                       '((self :num 0 :elapsed 0)))))
             (flat-records
              (cl-remove-if
               (lambda (rec) (= (plist-get (cdr rec) :num) 0))
               (flatten-records tree))))
        (setq max-time (mapreduceprop flat-records #'identity #'max :elapsed)
              max-total-time (mapreduceprop flat-records #'identity #'max :total)
              name-pad (mapreduceprop flat-records #'length #'max :name)
              num-pad (mapreduceprop flat-records
                                     (lambda (n) (length (number-to-string n)))
                                     #'max :num)
              max-depth (tree-depth tree))
        (with-current-buffer buf
          (erase-buffer)
          (setq-local outline-regexp "[0-9]+ *\\(?:• \\)*")
          (outline-minor-mode 1)
          (use-local-map (make-sparse-keymap))
          (local-set-key "TAB" #'outline-toggle-children)
          (local-set-key "\t" #'outline-toggle-children)
          (local-set-key (kbd "<backtab>") #'outline-show-subtree)
          (local-set-key (kbd "C-<iso-lefttab>")
                         (eval `(cmd! (if current-prefix-arg
                                          (outline-show-all)
                                        (outline-hide-sublevels (+ ,num-pad 2))))))
          (insert
           (propertize
            (concat (string-pad "#" num-pad) " "
                    (string-pad "Confpkg"
                                (+ name-pad (* 2 max-depth) -3))
                    (format " Load Time (Σ=%.3fs)\n"
                            (plist-get (cdr (assoc 'self tree)) :total)))
            'face '(:inherit (tab-bar-tab bold) :extend t :underline t)))
          (dolist (record (if sort-p
                              (sort-records-by-time tree)
                            (reverse (cdr tree))))
            (unless (eq (car record) 'self)
              (print-record record)))
          (set-buffer-modified-p nil)
          (goto-char (point-min)))
        (pop-to-buffer buf)))))
#+end_src

*** Finalise

At last, to clean up the content inserted by the babel calls we can just revert
the buffer. As long as ~org-babel-pre-tangle-hook~ hasn't been modified,
~save-buffer~ will be run at the start of the tangle process and so reverting will
take us back to just before the tangle started.

Since this is /the/ function added as the post-tangle hook, we also need to remove
the function from the hook and call the =config.el= creation function.

#+name: confpkg-finaliser
#+begin_src emacs-lisp
(defun confpkg-tangle-finalise ()
  (remove-hook 'org-babel-tangle-finished-hook #'confpkg-tangle-finalise)
  (revert-buffer t t t)
  (confpkg-comment-out-package-statements)
  (confpkg-annotate-list-dependencies)
  (confpkg-create-config)
  (confpkg-write-dependencies)
  (message "Processed %s elisp files" (length confpkg--list)))
#+end_src

Within ~confpkg-tangle-finalise~ we carefully order each step so that
the most important steps go first, to minimise the impact should a particular
step fail.

*** Bootstrap

This system makes use of some recent commits introduced to Org, such as [[https://git.savannah.gnu.org/cgit/emacs/org-mode.git/commit/?id=cb8bf4a0d][this
noweb expansion bugfix]] which will be included in Org 9.5.4. This is
problematic if using Emacs 28.2 or older, so to get around this we must go
through a bootstrap process.

[[xkcd:1739]]

To start with, we'll check if we are:
+ Running an Org version prior to 9.5.4
+ Running in a ~noninteractive~ session
+ Using an Org that's not installed in the user directory
+ In a session with the symbol ~exit!~ defined

#+name: bootstrap
#+begin_src emacs-lisp :noweb no-export
(let ((required-org-version "9.5.4")
      (standard-output t))
  (when (and (version< (org-version) required-org-version)
             (not (string-match-p (regexp-quote (expand-file-name "~"))
                                  (locate-library "org"))))
    (cond
     ((and noninteractive (fboundp 'exit!))
      (print! (warn (format "Detected conditions provoking a config bootstrap (Org %s)" (org-version))))
      (print! (start "Initiating bootstrap..."))
      <<bootstrap-perform>>
      )
     (t (message "Installed Org version %s is too old, %s is needed.\nRun \"doom sync\" to fix."
                 (org-version) required-org-version)))))
#+end_src

If these conditions are met, we can assume that the loaded Org version is
insufficient, and that it's likely a Emacs is currently running a command like
=doom sync=, and so it makes sense to perform the 3-step bootstrap.
1. Temporarily rename =config.org= to =config.original.org=.
2. Create a new =config.org= that when tangled results in Org being installed.
3. Swap back to the original =config.org=, and re-sync.

#+name: bootstrap-perform
#+begin_src emacs-lisp :noweb no-export
(print! (item "Temporarily relocating config.org to config.original.org"))
(rename-file "config.org" "config.original.org" t)
<<boostrap-create-transient-config>>
(print! (item "%s") (bold "Re-running sync"))
(exit! :restart) ; Re-run =doom sync= with the transient config.
#+end_src

With the approach worked out, we just need to generate a snipped that will
create a new =config.org= that when tangled:
+ Tangles our Org recipe to =packages.el=
+ Swaps back to the original =config.org=
+ Re-runs =doom sync=

#+name: boostrap-create-transient-config
#+begin_src emacs-lisp :noweb no-export
(print! (item "Creating minimal init.el"))

(let ((standard-output #'ignore))
  (with-temp-buffer
    (insert
     ";;; init.el -*- lexical-binding: t; -*-\n\n"
     (pp (quote
          <<bootstrap-init>>
          )))
    (write-region nil nil "init.el")))

(print! (item "Creating boostrap config.el"))

(let ((standard-output #'ignore))
  (with-temp-buffer
    (insert
     (org-element-interpret-data
      (list
       '(keyword (:key "title" :value "Boostrap Stage 1 Config" :post-blank 1))
       `(src-block
         (:language "emacs-lisp"
          :value ,(pp (quote (progn
                               <<boostrap-transition>>
                               )))
          :name "bootstrap-transition"
          :post-blank 1))
       `(src-block
         (:language "emacs-lisp"
          :parameters
          ,(concat ":noweb no-export "
                   ":tangle (expand-file-name (make-temp-name \"emacs-org-babel-excuses/confpkg-prepare-\") temporary-file-directory) "
                   ":mkdirp yes")
          :value ,(concat "<<" ; Split to avoid (prematurely) creating a noweb reference.
                          "bootstrap-transition()"
                          ">>\n"))))))
    (write-region nil nil "config.org")))
#+end_src

For the bootstrap we need a minimal =init.el=, just the literate module should be
sufficient.

#+name: bootstrap-init
#+begin_src emacs-lisp
(doom! :config literate)
#+end_src

This =config.org= simply provides an entry point for us to run elisp during
tangle. We just need to make use of it to install Org and re-sync the original
configuration.

There we go, that should do the trick, so long as we call the =bootstrap= block at
the start of the tangle process. This is done by calling =bootstrap= within the
[[Preparation][confpkg preparation]] stage.

** Personal Information

#+call: confpkg()

It's useful to have some basic personal information
#+begin_src emacs-lisp
(setq user-full-name "Josua Palmstedt"
      user-mail-address "palmstedt@posteo.de")
#+end_src
Apparently this is used by ~GPG~, and all sorts of other things.

Speaking of ~GPG~, I want to use =~/.authinfo.gpg= instead of the default in
=~/.config/emacs=. Why? Because my home directory is already cluttered, so this won't
make a difference, and I don't want to accidentally purge this file (I have done
src_shell{rm -rf~/.emac.d~ before}. I also want to cache as much as possible, as
my home machine is pretty safe, and my laptop is shutdown a lot.
#+begin_src emacs-lisp
(setq auth-sources '("~/.authinfo.gpg")
      auth-source-cache-expiry nil) ; default is 7200 (2h)
#+end_src

** Better defaults

#+call: confpkg()

*** Simple settings

Inspired by a few sources of modified defaults (such as [[https://github.com/angrybacon/dotemacs/blob/master/dotemacs.org#use-better-defaults][angrybacon/dotemacs]]) and
my own experiences, I've ended up with a small set of tweaks on top of the
changes Doom makes:

#+begin_src emacs-lisp
(setq-default
 delete-by-moving-to-trash t                      ; Delete files to trash
 window-combination-resize t                      ; take new window space from all other windows (not just current)
 x-stretch-cursor t)                              ; Stretch cursor to the glyph width

(setq undo-limit 80000000                         ; Raise undo-limit to 80Mb
      evil-want-fine-undo t                       ; By default while in insert all changes are one big blob. Be more granular
      auto-save-default t                         ; Nobody likes to loose work, I certainly don't
      truncate-string-ellipsis "…"                ; Unicode ellispis are nicer than "...", and also save /precious/ space
      password-cache-expiry nil                   ; I can trust my computers ... can't I?
      ;; scroll-preserve-screen-position 'always     ; Don't have `point' jump around
      scroll-margin 2                             ; It's nice to maintain a little margin
      display-time-default-load-average nil)      ; I don't think I've ever found this useful

(display-time-mode 1)                             ; Enable time in the mode-line
(global-subword-mode 1)                           ; Iterate through CamelCase words
#+end_src

When using a device with a battery, it would be nice to display battery
 information. We can check for a battery during tangle via noweb, and only call
 ~display-battery-mode~ when relevant. From a look at the various status functions
 in =battery.el=, it seems like the ~?L~ key is consistently =N/A= when there is no
 battery, so we'll test on that.

#+name: battery-status-setup
#+begin_src emacs-lisp :noweb-ref none
(require 'battery)
(if (and battery-status-function
         (not (equal (alist-get ?L (funcall battery-status-function))
                     "N/A")))
    (prin1-to-string `(display-battery-mode 1))
  "")
#+end_src

Now with noweb we' use the result.

#+begin_src emacs-lisp :noweb no-export 
<<battery-status-setup()>>
#+end_src

*** Frame sizing

It's nice to control the size of new frames, when launching Emacs that can be
done with src_shell{emacs -geometry 160x48}. After the font size adjustment
during initialisation this works out to be ~102x31~.

Thanks to hotkeys, it's easy for me to expand a frame to half/full-screen, so it
makes sense to be conservative with the sizing of new frames.

Then, for creating new frames within the same Emacs instance, we'll just set the
default to be something roughly 80% of that size.

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(height . 24))
(add-to-list 'default-frame-alist '(width . 80))
#+end_src

*** Auto-customisations

By default changes made via a customisation interface are added to =init.el=.
I prefer the idea of using a separate file for this. We just need to change a
setting, and load it if it exists.
#+begin_src emacs-lisp
(setq-default custom-file (expand-file-name ".custom.el" doom-private-dir))
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src

*** Windows

I find it rather handy to be asked which buffer I want to see after splitting
the window. Let's make that happen.

First, we'll enter the new window
#+begin_src emacs-lisp
(setq evil-vsplit-window-right t
      evil-split-window-below t)
#+end_src

Then, we'll pull up a buffer prompt.
#+begin_src emacs-lisp
(defadvice! prompt-for-buffer (&rest _)
  :after '(evil-window-split evil-window-vsplit)
  (consult-buffer))
#+end_src

Window rotation is nice, and can be found under =SPC w r= and =SPC w R=.
/Layout/ rotation is also nice though. Let's stash this under =SPC w SPC=, inspired
by Tmux's use of =C-b SPC= to rotate windows.

We could also do with adding the missing arrow-key variants of the window
navigation/swapping commands.
#+begin_src emacs-lisp
(map! :map evil-window-map
      "SPC" #'rotate-layout
      ;; Navigation
      "<left>"     #'evil-window-left
      "<down>"     #'evil-window-down
      "<up>"       #'evil-window-up
      "<right>"    #'evil-window-right
      ;; Swapping windows
      "C-<left>"       #'+evil/window-move-left
      "C-<down>"       #'+evil/window-move-down
      "C-<up>"         #'+evil/window-move-up
      "C-<right>"      #'+evil/window-move-right)
#+end_src

*** Buffer defaults

I'd much rather have my new buffers in ~org-mode~ than ~fundamental-mode~, hence
#+begin_src emacs-lisp
;; (setq-default major-mode 'org-mode)
#+end_src
For some reason this + the mixed pitch hook causes issues with hydra and so I'll
just need to resort to =SPC b o= for now.

** Doom configuration

#+call: confpkg("Doom")

*** Modules
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:

Doom has this lovely /modular configuration base/ that takes a lot of work out of
configuring Emacs. Each module (when enabled) can provide a list of packages to
install (on ~doom sync~) and configuration to be applied. The modules can also
have flags applied to tweak their behaviour.

#+name: init.el
#+attr_html: :collapsed t
#+begin_src emacs-lisp :tangle "init.el" :noweb no-export :noweb-ref none
;;; init.el -*- lexical-binding: t; -*-

;; This file controls what Doom modules are enabled and what order they load in.
;; Press 'K' on a module to view its documentation, and 'gd' to browse its directory.

(doom! :input
       <<doom-input>>

       :completion
       <<doom-completion>>

       :ui
       <<doom-ui>>

       :editor
       <<doom-editor>>

       :emacs
       <<doom-emacs>>

       :term
       <<doom-term>>

       :checkers
       <<doom-checkers>>

       :tools
       <<doom-tools>>

       :os
       <<doom-os>>

       :lang
       <<doom-lang>>

       :email
       <<doom-email>>

       :app
       <<doom-app>>

       :config
       <<doom-config>>
       )
#+end_src

**** Structure

As you may have noticed by this point, this is a [[https://en.wikipedia.org/wiki/Literate_programming][literate]] configuration. Doom
has good support for this which we access though the ~literate~ module.

While we're in the src_elisp{:config} section, we'll use Dooms nicer defaults,
along with the bindings and smartparens behaviour (the flags aren't documented,
but they exist).
#+name: doom-config
#+begin_src emacs-lisp
literate
(default +bindings +smartparens)
#+end_src

**** Interface

There's a lot that can be done to enhance Emacs' capabilities.
I reckon enabling half the modules Doom provides should do it.

#+name: doom-completion
#+begin_src emacs-lisp
(company                     ; the ultimate code completion backend
 +childframe)                ; ... when your children are better than you
;;helm                       ; the *other* search engine for love and life
;;ido                        ; the other *other* search engine...
;; (ivy                      ; a search engine for love and life
;;  +icons                   ; ... icons are nice
;;  +prescient)              ; ... I know what I want(ed)
(vertico +icons)             ; the search engine of the future
#+end_src

#+name: doom-ui
#+begin_src emacs-lisp
;;deft                       ; notational velocity for Emacs
doom                         ; what makes DOOM look the way it does
doom-dashboard               ; a nifty splash screen for Emacs
doom-quit                    ; DOOM quit-message prompts when you quit Emacs
;; (emoji +unicode)          ; 🙂
;; fill-column                ; a `fill-column' indicator
hl-todo                      ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
hydra                      ; quick documentation for related commands
;;indent-guides              ; highlighted indent columns, notoriously slow
(ligatures +extra)           ; ligatures and symbols to make your code pretty again
minimap                    ; show a map of the code on the side
modeline                     ; snazzy, Atom-inspired modeline, plus API
nav-flash                    ; blink the current line after jumping
;;neotree                    ; a project drawer, like NERDTree for vim
ophints                      ; highlight the region an operation acts on
(popup                       ; tame sudden yet inevitable temporary windows
 +all                        ; catch all popups that start with an asterix
 +defaults)                  ; default popup rules
;; (tabs                      ; an tab bar for Emacs
;; +centaur-tabs)           ; ... with prettier tabs
(treemacs +lsp)                    ; a project drawer, like neotree but cooler
;;unicode                    ; extended unicode support for various languages
(vc-gutter +pretty)          ; vcs diff in the fringe
vi-tilde-fringe              ; fringe tildes to mark beyond EOB
(window-select +numbers)     ; visually switch windows
workspaces                   ; tab emulation, persistence & separate workspaces
zen                          ; distraction-free coding or writing
#+end_src

#+name: doom-editor
#+begin_src emacs-lisp
(evil +everywhere)           ; come to the dark side, we have cookies
file-templates               ; auto-snippets for empty files
fold                         ; (nigh) universal code folding
(format +onsave)                     ; automated prettiness
;;god                        ; run Emacs commands without modifier keys
;;lispy                      ; vim for lisp, for people who don't like vim
multiple-cursors             ; editing in many places at once
;;objed                      ; text object editing for the innocent
;;parinfer                   ; turn lisp into python, sort of
rotate-text                  ; cycle region at point between text candidates
snippets                     ; my elves. They type so I don't have to
;;word-wrap                  ; soft wrapping with language-aware indent
#+end_src

#+name: doom-emacs
#+begin_src emacs-lisp
(dired +icons)               ; making dired pretty [functional]
electric                     ; smarter, keyword-based electric-indent
(ibuffer +icons)             ; interactive buffer management
undo                         ; persistent, smarter undo for your inevitable mistakes
vc                           ; version-control and Emacs, sitting in a tree
#+end_src

#+name: doom-term
#+begin_src emacs-lisp
;;eshell                     ; the elisp shell that works everywhere
;;shell                      ; simple shell REPL for Emacs
;;term                       ; basic terminal emulator for Emacs
vterm                        ; the best terminal emulation in Emacs
#+end_src

#+name: doom-checkers
#+begin_src emacs-lisp
(syntax                       ;tasing you for every semicolon you forget
  +childframe
  +flymake)
;; (:if (executable-find "aspell") spell) ; tasing you for misspelling mispelling
grammar                      ; tasing grammar mistake every you make
#+end_src

#+name: doom-tools
#+begin_src emacs-lisp
ansible                      ; a crucible for infrastructure as code
biblio                       ; Writes a PhD for you (citation needed)   ;;collab                     ; buffers with friends
debugger                     ; FIXME stepping through code, to help you add bugs
direnv                       ; be direct about your environment
docker                       ; port everything to containers
;;editorconfig               ; let someone else argue about tabs vs spaces
;;ein                        ; tame Jupyter notebooks with emacs
(eval +overlay)              ; run code, run (also, repls)
(lookup                      ; helps you navigate your code and documentation
 +dictionary                 ; dictionary/thesaurus is nice
 +docsets)                   ; ...or in Dash docsets locally
lsp                          ; Language Server Protocol
(magit                       ; a git porcelain for Emacs
 +forge)                     ; interface with git forges
make                         ; run make tasks from Emacs
;;pass                       ; password manager for nerds
pdf                          ; pdf enhancements
;;prodigy                    ; FIXME managing external services & code builders
rgb                          ; creating color strings
;;taskrunner                 ; taskrunner for all your projects
;;terraform                  ; infrastructure as code
;;tmux                       ; an API for interacting with tmux
tree-sitter                ; syntax and parsing, sitting in a tree...
upload                       ; map local to remote projects via ssh/ftp
#+end_src

#+name: doom-os
#+begin_src emacs-lisp
tty                          ; improve the terminal Emacs experience
#+end_src

**** Language support

We can be rather liberal with enabling support for languages as the associated
packages/configuration are (usually) only loaded when first opening an
associated file.

#+name: doom-lang
#+begin_src emacs-lisp
;;agda                       ; types of types of types of types...
;;beancount                  ; mind the GAAP
;;(cc +lsp)                  ; C > C++ == 1
;;clojure                    ; java with a lisp
;;common-lisp                ; if you've seen one lisp, you've seen them all
;;coq                        ; proofs-as-programs
;;crystal                    ; ruby at the speed of c
;;csharp                     ; unity, .NET, and mono shenanigans
data                         ; config/data formats
;;(dart +flutter)            ; paint ui and not much else
;;dhall                      ; JSON with FP sprinkles
;;elixir                     ; erlang done right
;;elm                        ; care for a cup of TEA?
emacs-lisp                   ; drown in parentheses
;;erlang                     ; an elegant language for a more civilized age
ess                          ; emacs speaks statistics
;;factor
;;faust                      ; dsp, but you get to keep your soul
;;fortran                    ; in FORTRAN, GOD is REAL (unless declared INTEGER)
;;fsharp                     ; ML stands for Microsoft's Language
;;fstar                      ; (dependent) types and (monadic) effects and Z3
;;gdscript                   ; the language you waited for
(go
 +tree-sitter
 +lsp)                       ; the hipster dialect
;;(graphql +lsp)             ; Give queries a REST
;;(haskell +lsp)             ; a language that's lazier than I am
;;hy                         ; readability of scheme w/ speed of python
;;idris                      ;
json                         ; At least it ain't XML
;;(java +lsp)                ; the poster child for carpal tunnel syndrome
(javascript +lsp)            ; all(hope(abandon(ye(who(enter(here))))))
(julia +lsp)                 ; Python, R, and MATLAB in a blender
;;kotlin                     ; a better, slicker Java(Script)
(latex                       ; writing papers in Emacs has never been so fun
 +latexmk                    ; what else would you use?
 +cdlatex                    ; quick maths symbols
 +fold)                      ; fold the clutter away nicities
;;lean                       ; proof that mathematicians need help
;;factor                     ; for when scripts are stacked against you
;;ledger                     ; an accounting system in Emacs
lua                          ; one-based indices? one-based indices
markdown                     ; writing docs for people to ignore
;;nim                        ; python + lisp at the speed of c
nix                          ; I hereby declare "nix geht mehr!"
;;ocaml                      ; an objective camel
(org                         ; organize your plain life in plain text
 +dragndrop                  ; drag & drop files/images into org buffers
 ;;+hugo                     ; use Emacs for hugo blogging
 +noter                      ; enhanced PDF notetaking
 +jupyter                    ; ipython/jupyter support for babel
 +pandoc                     ; export-with-pandoc support
 +gnuplot                    ; who doesn't like pretty pictures
 +pomodoro                 ; be fruitful with the tomato technique
 +present                    ; using org-mode for presentations
 +roam2)                     ; wander around notes
;;php                        ; perl's insecure younger brother
;;plantuml                   ; diagrams for confusing people more
;;purescript                 ; javascript, but functional
(python +lsp +pyright)       ; beautiful is better than ugly
;;qt                         ; the 'cutest' gui framework ever
;;racket                     ; a DSL for DSLs
;;raku                       ; the artist formerly known as perl6
;;rest                       ; Emacs as a REST client
;;rst                        ; ReST in peace
;;(ruby +rails)              ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
(rust +lsp)                  ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
;;scala                      ; java, but good
scheme                       ; a fully conniving family of lisps
sh                           ; she sells {ba,z,fi}sh shells on the C xor
;;sml                        ; no, the /other/ ML
;;solidity                   ; do you need a blockchain? No.
;;swift                      ; who asked for emoji variables?
;;terra                      ; Earth and Moon in alignment for performance.
web                          ; the tubes
yaml                         ; JSON, but readable
;;zig                        ; C, but simpler
#+end_src

**** Input

#+name: doom-input
#+begin_src emacs-lisp
;;bidi                       ; (tfel ot) thgir etirw uoy gnipleh
;;chinese
;;japanese
;;layout                     ; auie,ctsrnm is the superior home row
#+end_src

**** Everything in Emacs

It's just too convenient being able to have everything in Emacs.
I couldn't resist the Email and Feed modules.

#+name: doom-email
#+begin_src emacs-lisp
(:if (executable-find "mu") (mu4e +org))
;;notmuch
;;(wanderlust +gmail)
#+end_src

#+name: doom-app
#+begin_src emacs-lisp
;;calendar                   ; A dated approach to timetabling
;;emms                       ; Multimedia in Emacs is music to my ears
everywhere                   ; *leave* Emacs!? You must be joking.
irc                          ; how neckbeards socialize
(rss +org)                   ; emacs as an RSS reader
;;twitter                    ; twitter client https://twitter.com/vnought
#+end_src

*** Profiles

Doom has support for multiple configuration profiles. For general usage, this
isn't a particularly useful feature, but for niche use cases it's fantastic.

#+begin_src emacs-lisp :tangle ~/.config/emacs/profiles.el :noweb-ref none
((orgdev (env ("DOOMDIR" . "~/.config/doom.orgdev"))))
#+end_src

**** Org development profile
:PROPERTIES:
:header-args:emacs-lisp: :noweb-ref none
:END:

For development purposes, it's handy to have a more minimal config without my
many customisations and interacting packages. Let's go ahead and create a
near-minimal new config:

#+begin_src emacs-lisp :tangle ../doom.orgdev/init.el :mkdirp yes
;;; init.el -*- lexical-binding: t; -*-
(doom! :completion vertico
       :editor evil
       :config (default +bindings))
#+end_src

#+begin_src emacs-lisp :tangle ../doom.orgdev/packages.el :noweb no-export
(unpin! org) ; there be bugs
#+end_src

#+begin_src emacs-lisp :tangle ../doom.orgdev/config.el
(require 'org)
(load-theme 'modus-operandi t)
#+end_src

*** Visual Settings
**** Font Face
***** Setting fonts

'Fira Code' is nice, and 'Overpass' makes for a nice sans companion. We just need to
fiddle with the font sizes a tad so that they visually match. Just for fun I'm
trying out JetBrains Mono though. So far I have mixed feelings on it, some
aspects are nice, but on others I prefer Fira.

#+begin_src emacs-lisp
(setq doom-font (font-spec :family "JetBrainsMono NF" :size 20)
      doom-big-font (font-spec :family "JetBrainsMono NF" :size 36)
      ;;doom-variable-pitch-font (font-spec :family "Avenir Next LT Pro" :size 28)
      ;;doom-variable-pitch-font (font-spec :family "Source Sans 3" :size 28 :weight 'light)
      doom-variable-pitch-font (font-spec :family "Source Sans 3" :size 24)
      ;;doom-variable-pitch-font (font-spec :family "Metropolis" :size 28 :weight 'light)
      ;;doom-variable-pitch-font (font-spec :family "IBM Plex Sans" :size 28 :weight 'light)
      doom-unicode-font (font-spec :family "JuliaMono")
      ;; doom-emoji-font (font-spec :family "Twitter Color Emoji") ; Just used by me
      doom-serif-font (font-spec :family "IBM Plex Mono" :size 22 :weight 'light))
#+end_src

#+attr_html: :class invertible :alt Screenshot of the fonts within Emacs.
[[https://tecosaur.com/lfs/emacs-config/screenshots/font-face.png]]

In addition to these fonts, Merriweather is used with =nov.el=, and Alegreya as a
serifed proportional font used by =mixed-pitch-mode= for =writeroom-mode= with Org
files.

***** Checking the system

Because we care about how things look let's add a check to make sure we're told
if the system doesn't have any of those fonts. We can obtain a list of installed
fonts with either ~(font-family-list)~ or with the ~fc-list~ command.

#+name: detect-missing-fonts
#+begin_src emacs-lisp :noweb-ref none
(setq required-fonts '("JetBrains ?Mono.*" "Overpass" "JuliaMono" "IBM Plex Mono"
                       "Merriweather" "Alegreya"))

(setq available-fonts
      (delete-dups
       (or (font-family-list)
           (and (executable-find "fc-list")
                (with-temp-buffer
                  (call-process "fc-list" nil t nil ":" "family")
                  (split-string (buffer-string) "[,\n]"))))))

(setq missing-fonts
      (delq nil (mapcar
                 (lambda (font)
                   (unless (delq nil (mapcar (lambda (f)
                                               (string-match-p (format "^%s$" font) f))
                                             available-fonts))
                     font))
                 required-fonts)))
#+end_src

We can then use this to create a =doctor= check.

#+begin_src emacs-lisp :noweb yes :noweb-ref doctor
(let (required-fonts available-fonts missing-fonts)
  <<detect-missing-fonts>>
  (if available-fonts
      (dolist (font missing-fonts)
        (warn! (format "Missing font: %s." font)))
    (warn! "Unable to check for missing fonts, is fc-list installed?")))
#+end_src

Furthermore, when fonts /are/ missing, it could be good to check the state of
affairs on statup.

#+name: warn-missing-fonts
#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref none
<<detect-missing-fonts>>

(if missing-fonts
    (pp-to-string
     `(unless noninteractive
        (add-hook! 'doom-init-ui-hook
          (run-at-time nil nil
                       (lambda ()
                         (let (required-fonts available-fonts missing-fonts)
                           <<detect-missing-fonts>>
                           (message "%s missing the following fonts: %s"
                                    (propertize "Warning!" 'face '(bold warning))
                                    (mapconcat (lambda (font)
                                                 (propertize font 'face 'font-lock-variable-name-face))
                                               ',missing-fonts
                                               ", ")))
                         (sleep-for 0.5))))))
  ";; No missing fonts detected")
#+end_src

#+begin_src emacs-lisp :noweb no-export
<<warn-missing-fonts()>>
#+end_src

This way whenever fonts are missing, after Doom's UI has initialised, a warning
listing the missing fonts should appear for at least half a second.

**** Theme

The ~doom-one~ theme is nice and all, but I find the ~vibrant~ variant nicer. With
the light themes, I rather like ~doom-tomorrow-day~. I'd like to pick the default
from them based on the system theme. We can detect this with a ~gdbus~ call, which
is a Gnome CLI tool but often present on KDE systems for GTK support.

#+name: default-theme
#+begin_src emacs-lisp :noweb-ref none
(let ((light-theme 'doom-tomorrow-day)
      (dark-theme 'doom-vibrant)
      (system-light-p
       (and
        (executable-find "gdbus")
        (string= "<<uint32 2>>"
                 (with-temp-buffer
                   (call-process "gdbus" nil t nil
                                 "call" "--session"
                                 "--timeout=1000"
                                 "--dest=org.freedesktop.portal.Desktop"
                                 "--object-path" "/org/freedesktop/portal/desktop"
                                 "--method" "org.freedesktop.portal.Settings.Read"
                                 "org.freedesktop.appearance" "color-scheme")
                   (string-trim (buffer-string) "(" ",)\n"))))))
  (if system-light-p light-theme dark-theme))
#+end_src

We'll use the appropriate theme as the default, but let's also accept the theme
as an envvar for fun.

#+begin_src emacs-lisp :noweb yes
(setq doom-theme
      (if (getenv "DOOM_THEME")
          (intern (getenv "DOOM_THEME"))
        '<<default-theme()>>))
#+end_src

Oh, and with the nice selection doom provides there's no reason for me to want
the defaults.

#+begin_src emacs-lisp
(delq! t custom-theme-load-path)
#+end_src

Lastly, I had some issues with theme race conditions, which seem to be resolved
by moving =doom-init-theme-h= around. Henrik attempted to help with this in May
2021 but we didn't manage to pin down the issue. It may be worth periodically
checking back and seeing if this is still needed.

#+begin_src emacs-lisp
(remove-hook 'window-setup-hook #'doom-init-theme-h)
(add-hook 'after-init-hook #'doom-init-theme-h 'append)
#+end_src

**** Line numbers

Relative line numbers are fantastic for knowing how far away line numbers are,
then =ESC 12 <UP>= gets you exactly where you think.

#+begin_src emacs-lisp
(setq display-line-numbers-type 'relative)
#+end_src

*** Some helper macros

There are a few handy macros added by doom, namely
- ~load!~ for loading external ~.el~ files relative to this one
- ~use-package!~ for configuring packages
- ~add-load-path!~ for adding directories to the ~load-path~ where ~Emacs~ looks when
  you load packages with ~require~ or ~use-package~
- ~map!~ for binding new keys

*** Allow babel execution in CLI actions

In this config I sometimes generate code to include in my config.
This works nicely, but for it to work with =doom sync= et. al. I need to make sure
that Org doesn't try to confirm that I want to allow evaluation (I do!).

Thankfully Doom supports =$DOOMDIR/cli.el= file which is sourced every time a CLI
command is run, so we can just enable evaluation by setting
~org-confirm-babel-evaluate~ to ~nil~ there.
While we're at it, we should silence ~org-babel-execute-src-block~ to
avoid polluting the output.

#+begin_src emacs-lisp :tangle cli.el :noweb-ref none
;;; cli.el -*- lexical-binding: t; -*-
(setq org-confirm-babel-evaluate nil)

(defun doom-shut-up-a (orig-fn &rest args)
  (quiet! (apply orig-fn args)))

(advice-add 'org-babel-execute-src-block :around #'doom-shut-up-a)
#+end_src

*** Org buffer creation

Let's make creating an Org buffer just that little bit easier.

#+begin_src emacs-lisp
(evil-define-command +evil-buffer-org-new (count file)
  "Creates a new ORG buffer replacing the current window, optionally
   editing a certain FILE"
  :repeat nil
  (interactive "P<f>")
  (if file
      (evil-edit file)
    (let ((buffer (generate-new-buffer "*new org*")))
      (set-window-buffer nil buffer)
      (with-current-buffer buffer
        (org-mode)
        (setq-local doom-real-buffer-p t)))))

(map! :leader
      (:prefix "b"
       :desc "New empty Org buffer" "o" #'+evil-buffer-org-new))
#+end_src

*** Dashboard

# #+call: confpkg()

# **** Quick actions

# When using the dashboard, there are often a small number of actions I will take.
# As the dashboard is it's own major mode, there is no need to suffer the tyranny
# of unnecessary keystrokes --- we can simply bind common actions to a single key!

# #+begin_src emacs-lisp
# (defun +doom-dashboard-setup-modified-keymap ()
#   (setq +doom-dashboard-mode-map (make-sparse-keymap))
#   (map! :map +doom-dashboard-mode-map
#         :desc "Find file" :ng "f" #'find-file
#         :desc "Recent files" :ng "r" #'consult-recent-file
#         :desc "Config dir" :ng "C" #'doom/open-private-config
#         :desc "Open config.org" :ng "c" (cmd! (find-file (expand-file-name "config.org" doom-user-dir)))
#         :desc "Open org-mode root" :ng "O" (cmd! (find-file (expand-file-name "lisp/org/" doom-user-dir)))
#         :desc "Open dotfile" :ng "." (cmd! (doom-project-find-file "~/.config/"))
#         :desc "Notes (roam)" :ng "n" #'org-roam-node-find
#         :desc "Switch buffer" :ng "b" #'+vertico/switch-workspace-buffer
#         :desc "Switch buffers (all)" :ng "B" #'consult-buffer
#         :desc "IBuffer" :ng "i" #'ibuffer
#         :desc "Previous buffer" :ng "p" #'previous-buffer
#         :desc "Set theme" :ng "t" #'consult-theme
#         :desc "Quit" :ng "Q" #'save-buffers-kill-terminal
#         :desc "Show keybindings" :ng "h" (cmd! (which-key-show-keymap '+doom-dashboard-mode-map))))

# (add-transient-hook! #'+doom-dashboard-mode (+doom-dashboard-setup-modified-keymap))
# (add-transient-hook! #'+doom-dashboard-mode :append (+doom-dashboard-setup-modified-keymap))
# (add-hook! 'doom-init-ui-hook :append (+doom-dashboard-setup-modified-keymap))
# #+end_src

# Unfortunately the show keybindings help doesn't currently work as intended, but
# this is still quite nice overall.

# Now that the dashboard is so convenient, I'll want to make it easier to get to.
# #+begin_src emacs-lisp
# (map! :leader :desc "Dashboard" "d" #'+doom-dashboard/open)
# #+end_src

# **** Putting it all together

# With the splash image and phrase generation worked out, we can almost put
# together the desired dashboard from scratch, we just need to re-create the
# benchmark information by itself.

# #+begin_src emacs-lisp
# (defun +doom-dashboard-benchmark-line ()
#   "Insert the load time line."
#   (when doom-init-time
#     (insert
#      "\n\n"
#      (propertize
#       (+doom-dashboard--center
#        +doom-dashboard--width
#        (doom-display-benchmark-h 'return))
#       'face 'doom-dashboard-loaded))))
# #+end_src

# With ~doom-display-benchmark-h~ displayed here, I don't see the need for it to be
# shown in the minibuffer as well.

# #+begin_src emacs-lisp
# (remove-hook 'doom-after-init-hook #'doom-display-benchmark-h)
# #+end_src

# Now we can create the desired dashboard by setting ~+doom-dashboard-functions~ to
# just have:
# + The "widget banner" (splash image)
# + The benchmark line
# + A random phrase
# This gets rid of two segments I'm not particularly interested in seeing
# + The shortmenu
# + The footer (github link)

# #+begin_src emacs-lisp
# (setq +doom-dashboard-functions
#       (list #'doom-dashboard-widget-banner
#             #'+doom-dashboard-benchmark-line
#             #'splash-phrase-dashboard-insert))
# #+end_src

# At this point there are just a few minor tweaks I'd still like to make to the
# dashboard.

# #+begin_src emacs-lisp
# (defun +doom-dashboard-tweak (&optional _)
#   (with-current-buffer (get-buffer +doom-dashboard-name)
#     (setq-local line-spacing 0.2
#                 mode-line-format nil
#                 evil-normal-state-cursor (list nil))))
# #+end_src

# Now we can just add this as a mode hook.

# #+begin_src emacs-lisp
# (add-hook '+doom-dashboard-mode-hook #'+doom-dashboard-tweak)
# #+end_src

# Unfortunately, the initialisation of =doom-modeline= interferes with the set
# ~mode-line-format~ value. To get around this, we can re-apply
# ~+doom-dashboard-tweak~ as a slightly late init hook, after =doom-modeline= has been
# loaded.

# #+begin_src emacs-lisp
# (add-hook 'doom-after-init-hook #'+doom-dashboard-tweak 1)
# #+end_src

# Lastly, with the buffer name being shown in the frame title thanks to some [[Window title][other
# configuration]], we might as well display something a bit prettier than =*doom*=.

# #+begin_src emacs-lisp
# (setq +doom-dashboard-name "► Doom"
#       doom-fallback-buffer-name +doom-dashboard-name)
# #+end_src

# The end result is a minimal but rather nice splash screen.

# #+attr_html: :class invertible :alt The splash screen, just loaded.
# [[https://tecosaur.com/lfs/emacs-config/screenshots/splash-screen.png]]

# To keep the splash image up to date, we just need to check it every time the
# frame size or theme is changed.

# #+begin_src emacs-lisp
# (add-hook 'window-size-change-functions #'fancy-splash-apply-appropriate-image)
# (add-hook 'doom-load-theme-hook #'fancy-splash-apply-appropriate-image)
# #+end_src

*** Config doctor

We can collect checks throughout this config and put them in a =doctor.el= file
that will be run as part of =doom doctor=. This will complement the =setup.sh=
approach.

#+begin_src emacs-lisp :tangle doctor.el :noweb yes :noweb-ref none
;;; doctor.el -*- lexical-binding: t; no-byte-compile: t; -*-

<<doctor>>
#+end_src

** Other things

# This stub for the shell setup scrip needs to appear before any
# other setup shell source blocks.
#+begin_src shell :exports none :comments no :tangle-mode (identity #o755)
#!/usr/bin/env bash
#+end_src

*** Editor interaction
**** Mouse buttons

#+call: confpkg("Better jumper mouse")

#+begin_src emacs-lisp
(map! :n [mouse-8] #'better-jumper-jump-backward
      :n [mouse-9] #'better-jumper-jump-forward)
#+end_src

*** Window title

#+call: confpkg("Frame title")

I'd like to have just the buffer name, then if applicable the project folder
#+begin_src emacs-lisp
(setq frame-title-format
      '(""
        (:eval
         (if (string-match-p (regexp-quote (or (bound-and-true-p org-roam-directory) "\u0000"))
                             (or buffer-file-name ""))
             (replace-regexp-in-string
              ".*/[0-9]*-?" "☰ "
              (subst-char-in-string ?_ ?\s buffer-file-name))
           "%b"))
        (:eval
         (when-let ((project-name (and (featurep 'projectile) (projectile-project-name))))
           (unless (string= "-" project-name)
             (format (if (buffer-modified-p)  " ◉ %s" "  ●  %s") project-name))))))
#+end_src

For example when I open my config file it the window will be titled =config.org ●
doom= then as soon as I make a change it will become =config.org ◉ doom=.

*** Systemd daemon

For running a systemd service for a Emacs server I have the following. =zsh -c= is
used to ensure that =.zshenv= is loaded.

#+name: emacsclient service
#+begin_src systemd :tangle ~/.config/systemd/user/emacs.service :mkdirp yes
[Unit]
Description=Emacs server daemon
Documentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/
Wants=gpg-agent.service

[Service]
Type=forking
ExecStart=zsh -c 'emacs --daemon && emacsclient -c --eval "(delete-frame)"'
ExecStop=/usr/bin/emacsclient --no-wait --eval "(progn (setq kill-emacs-hook nil) (kill emacs))"
Environment=COLORTERM=truecolor
Restart=on-failure

[Install]
WantedBy=default.target
#+end_src

which is then enabled by
#+begin_src shell :tangle (if (string= "enabled\n" (shell-command-to-string "systemctl --user is-enabled emacs.service")) "no" "setup.sh")
systemctl --user enable emacs.service
#+end_src

We can also add a =doctor= warning should this not be enabled.

#+begin_src emacs-lisp :noweb-ref doctor
(unless (string= "enabled\n" (shell-command-to-string "systemctl --user is-enabled emacs.service"))
  (warn! "Emacsclient service is not enabled."))
#+end_src

For some reason if a frame isn't opened early in the initialisation process, the
daemon doesn't seem to like opening frames later --- hence the ~&& emacsclient~
part of the =ExecStart= value.

It can now be nice to use this as a 'default app' for opening files. If we add
an appropriate desktop entry, and enable it in the desktop environment.

#+begin_src conf :tangle ~/.local/share/applications/emacs-client.desktop :mkdirp yes
[Desktop Entry]
Name=Emacs client
GenericName=Text Editor
Comment=A flexible platform for end-user applications
MimeType=text/english;text/plain;text/x-makefile;text/x-c++hdr;text/x-c++src;text/x-chdr;text/x-csrc;text/x-java;text/x-moc;text/x-pascal;text/x-tcl;text/x-tex;application/x-shellscript;text/x-c;text/x-c++;
Exec=emacsclient -create-frame --alternate-editor="" --no-wait %F
Icon=emacs
Type=Application
Terminal=false
Categories=TextEditor;Utility;
StartupWMClass=Emacs
Keywords=Text;Editor;
X-KDE-StartupNotify=false
#+end_src

When the daemon is running, I almost always want to do a few particular things
with it, so I may as well eat the load time at startup. We also want to keep
=mu4e= running.

It would be good to start the IRC client (=circe=) too, but that seems to have
issues when started in a non-graphical session.

Lastly, while I'm not sure quite why it happens, but after a bit it seems that
new Emacsclient frames start on the =*scratch*= buffer instead of the dashboard.
I prefer the dashboard, so let's ensure that's always switched to in new frames.

#+call: confpkg("Emacs daemon setup")

#+name: daemon initialisation
#+begin_src emacs-lisp
(defun greedily-do-daemon-setup ()
  (require 'org)
  (when (require 'mu4e nil t)
    (setq mu4e-confirm-quit t)
    (setq +mu4e-lock-greedy t)
    (setq +mu4e-lock-relaxed t)
    (when (+mu4e-lock-available t)
      (mu4e--start)))
  (when (require 'elfeed nil t)
    (run-at-time nil (* 8 60 60) #'elfeed-update)))

(when (daemonp)
  (add-hook 'emacs-startup-hook #'greedily-do-daemon-setup)
  (add-hook! 'server-after-make-frame-hook
    (unless (string-match-p "\\*draft\\|\\*stdin\\|emacs-everywhere" (buffer-name))
      (switch-to-buffer +doom-dashboard-name))))
#+end_src

*** Emacs client wrapper

I frequently want to make use of Emacs while in a terminal emulator. To make
this easier, I can construct a few handy aliases.

However, a little convenience script in =~/.local/bin= can have the same effect,
be available beyond the specific shell I plop the alias in, then also allow me
to add a few bells and whistles --- namely:
+ Accepting stdin by putting it in a temporary file and immediately opening it.
+ Guessing that the =tty= is a good idea when ~$DISPLAY~ is unset (relevant with SSH
  sessions, among other things).
+ With a whiff of 24-bit color support, sets ~TERM~ variable to a =terminfo= that
  (probably) announces 24-bit color support.
+ Changes GUI =emacsclient= instances to be non-blocking by default (~--no-wait~),
  and instead take a flag to suppress this behaviour (~-w~).

I would use =sh=, but using arrays for argument manipulation is just too
convenient, so I'll raise the requirement to =bash=. Since arrays are the only
'extra' compared to =sh=, other shells like =ksh= etc. should work too.

#+name: e
#+begin_src shell :tangle ~/.local/bin/e :mkdirp yes :tangle-mode (identity #o755) :comments no
#!/usr/bin/env bash
force_tty=false
force_wait=false
stdin_mode=""

args=()

while :; do
    case "$1" in
        -t | -nw | --tty)
            force_tty=true
            shift ;;
        -w | --wait)
            force_wait=true
            shift ;;
        -m | --mode)
            stdin_mode=" ($2-mode)"
            shift 2 ;;
        -h | --help)
            echo -e "\033[1mUsage: e [-t] [-m MODE] [OPTIONS] FILE [-]\033[0m

Emacs client convenience wrapper.

\033[1mOptions:\033[0m
\033[0;34m-h, --help\033[0m            Show this message
\033[0;34m-t, -nw, --tty\033[0m        Force terminal mode
\033[0;34m-w, --wait\033[0m            Don't supply \033[0;34m--no-wait\033[0m to graphical emacsclient
\033[0;34m-\033[0m                     Take \033[0;33mstdin\033[0m (when last argument)
\033[0;34m-m MODE, --mode MODE\033[0m  Mode to open \033[0;33mstdin\033[0m with

Run \033[0;32memacsclient --help\033[0m to see help for the emacsclient."
            exit 0 ;;
        --*=*)
            set -- "$@" "${1%%=*}" "${1#*=}"
            shift ;;
        ,*)
            if [ "$#" = 0 ]; then
                break; fi
            args+=("$1")
            shift ;;
    esac
done

if [ ! "${#args[*]}" = 0 ] && [ "${args[-1]}" = "-" ]; then
    unset 'args[-1]'
    TMP="$(mktemp /tmp/emacsstdin-XXX)"
    cat > "$TMP"
    args+=(--eval "(let ((b (generate-new-buffer \"*stdin*\"))) (switch-to-buffer b) (insert-file-contents \"$TMP\") (delete-file \"$TMP\")${stdin_mode})")
fi

if [ -z "$DISPLAY" ] || $force_tty; then
    # detect terminals with sneaky 24-bit support
    if { [ "$COLORTERM" = truecolor ] || [ "$COLORTERM" = 24bit ]; } \
        && [ "$(tput colors 2>/dev/null)" -lt 257 ]; then
        if echo "$TERM" | grep -q "^\w\+-[0-9]"; then
            termstub="${TERM%%-*}"; else
            termstub="${TERM#*-}"; fi
        if infocmp "$termstub-direct" >/dev/null 2>&1; then
            TERM="$termstub-direct"; else
            TERM="xterm-direct"; fi # should be fairly safe
    fi
    emacsclient --tty -create-frame --alternate-editor="$ALTERNATE_EDITOR" "${args[@]}"
else
    if ! $force_wait; then
        args+=(--no-wait); fi
    emacsclient -create-frame --alternate-editor="$ALTERNATE_EDITOR" "${args[@]}"
fi
#+end_src

Now, to set an alias to use =e= with magit, and then for maximum laziness we can
set aliases for the terminal-forced variants.
#+begin_src shell :tangle no
alias m='e --eval "(progn (magit-status) (delete-other-windows))"'
alias mt="m -t"
alias et="e -t"
#+end_src

*** Prompt to run setup script

#+call: confpkg("Setup script prompt")

At various points in this config, content is conditionally tangled to
=./setup.sh=. It's no good just putting content there if it isn't run though.
To help remind me to run it when needed, let's add a little prompt when there's
anything to be run.

#+name: run-setup
#+begin_src emacs-lisp :tangle no
(if (file-exists-p "setup.sh")
    (if (string-empty-p (string-trim (with-temp-buffer (insert-file-contents "setup.sh") (buffer-string)) "#!/usr/bin/env bash"))
        (message ";; Setup script is empty")
      (message ";; Detected content in the setup script")
      (pp-to-string
       `(unless noninteractive
          (defun +config-run-setup ()
            (when (yes-or-no-p (format "%s The setup script has content. Check and run the script?"
                                       (propertize "Warning!" 'face '(bold warning))))
              (find-file (expand-file-name "setup.sh" doom-private-dir))
              (when (yes-or-no-p "Would you like to run this script?")
                (async-shell-command "./setup.sh"))))
          (add-hook! 'doom-init-ui-hook
            (run-at-time nil nil #'+config-run-setup)))))
  (message ";; setup.sh did not exist during tangle. Tangle again.")
  (pp-to-string
   `(unless noninteractive
      (add-hook! 'doom-init-ui-hook #'+literate-tangle-async-h))))
#+end_src

#+begin_src emacs-lisp :noweb no-export
<<run-setup()>>
#+end_src

*** Grabbing source block content as a string

In a few places in this configuration, it is desirable to grab a source block's
content as a string. We can use a noweb =<<replacement>>= form, however that
doesn't work with string escaping.

We can get around this by using noweb execution and write an name (unexported)
babel block that will grab the content of another named source block as a
string. Note that this does not currently expand nested noweb references.

#+name: grab
#+begin_src emacs-lisp :var name="" :noweb-ref none
(if-let ((block-pos (org-babel-find-named-block name))
         (block (org-element-at-point block-pos)))
    (format "%S" (string-trim (org-element-property :value block)))
  ;; look for :noweb-ref matches
  (let (block-contents)
    (org-element-cache-map
     (lambda (src)
       (when (and (not (org-in-commented-heading-p nil src))
                  (not (org-in-archived-heading-p nil src))
                  (let* ((lang (org-element-property :language src))
                         (params
                          (apply
                           #'org-babel-merge-params
                           (append
                            (org-with-point-at (org-element-property :begin src)
                              (org-babel-params-from-properties lang t))
                            (mapcar
                             (lambda (h)
                               (org-babel-parse-header-arguments h t))
                             (cons (org-element-property :parameters src)
                                   (org-element-property :header src))))))
                         (ref (alist-get :noweb-ref params)))
                    (equal ref name)))
         (push (org-babel--normalize-body src)
               block-contents)))
     :granularity 'element
     :restrict-elements '(src-block))
    (and block-contents
         (format "%S"
                 (mapconcat
                  #'identity
                  (nreverse block-contents)
                  "\n\n")))))
#+end_src

There we go, that's all it takes! This can be used via the form =<<grab("block-name")>>=.

* Packages
** Loading instructions
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:

This is where you install packages, by declaring them with the ~package!~ macro in
=packages.el=, then running ~doom refresh~ on the command line.
This file shouldn't be byte compiled.
#+begin_src emacs-lisp :tangle "packages.el" :comments no
;; -*- no-byte-compile: t; -*-
#+end_src

You'll then need to restart Emacs for your changes to take effect! Or at least,
run =M-x doom/reload=.

*Warning*: Don't disable core packages listed in =~/.config/emacs/core/packages.el=.
Doom requires these, and disabling them may have terrible side effects.

*** Packages in MELPA/ELPA/emacsmirror

To install ~some-package~ from MELPA, ELPA or emacsmirror:
#+begin_src emacs-lisp
(package! some-package)
#+end_src

*** Packages from git repositories

To install a package directly from a particular repo, you'll need to specify
a ~:recipe~. You'll find documentation on what ~:recipe~ accepts [[https://github.com/raxod502/straight.el#the-recipe-format][here]]:
#+begin_src emacs-lisp
(package! another-package
  :recipe (:host github :repo "username/repo"))
#+end_src

If the package you are trying to install does not contain a ~PACKAGENAME.el~
file, or is located in a subdirectory of the repo, you'll need to specify
~:files~ in the ~:recipe~:
#+begin_src emacs-lisp
(package! this-package
  :recipe (:host github :repo "username/repo"
           :files ("some-file.el" "src/lisp/*.el")))
#+end_src

*** Disabling built-in packages

If you'd like to disable a package included with Doom, for whatever reason,
you can do so here with the ~:disable~ property:
#+begin_src emacs-lisp
(package! builtin-package :disable t)
#+end_src
You can override the recipe of a built in package without having to specify
all the properties for ~:recipe~. These will inherit the rest of its recipe
from Doom or MELPA/ELPA/Emacsmirror:
#+begin_src emacs-lisp
(package! builtin-package :recipe (:nonrecursive t))
(package! builtin-package-2 :recipe (:repo "myfork/package"))
#+end_src

Specify a ~:branch~ to install a package from a particular branch or tag.
#+begin_src emacs-lisp
(package! builtin-package :recipe (:branch "develop"))
#+end_src

** Convenience
*** Avy

#+call: confpkg("!Pkg avy")

#+begin_quote
From the =:config default= module.
#+end_quote


What a wonderful way to jump to buffer positions, and it uses the QWERTY
home-row for jumping. Very convenient ... except I'm using Colemak.

#+name: avy-colemak-setup
#+begin_src emacs-lisp :noweb-ref none
(after! avy
  ;; home row priorities: 8 6 4 5 - - 1 2 3 7
  (setq avy-keys '(?n ?e ?i ?s ?t ?r ?i ?a)))
#+end_src

Now let's just have this included when an ErgoDox is found via =dmesg=.

#+name: avy-detect-colemak
#+begin_src emacs-lisp :noweb no-export :noweb-ref none :noweb-prefix no
(if (= 0 (call-process "sh" nil nil nil "-c" "dmesg | grep -q 'ErgoDox'"))
    (pp '<<avy-colemak-setup>>)
  ";; Avy: Colemak layout not detected (ErgoDox not mentioned in dmesg).")
#+end_src

#+begin_src emacs-lisp :noweb no-export
<<avy-detect-colemak()>>
#+end_src

*** Rotate (window management)

The =rotate= package just adds the ability to rotate window layouts, but that
sounds nice to me.

#+begin_src emacs-lisp :tangle packages.el
(package! rotate :pin "4e9ac3ff800880bd9b705794ef0f7c99d72900a6")
#+end_src

*** Emacs Everywhere

#+call: confpkg("!Pkg emacs-everywhere")

The name says it all. It's loaded and set up (a bit) by =:app everywhere=, however
as I develop this I want the unpinned version I have as a submodule.

#+begin_src emacs-lisp :tangle packages.el
(package! emacs-everywhere :recipe (:local-repo "lisp/emacs-everywhere"))
(unpin! emacs-everywhere)
#+end_src

Additionally, I'm going to make some personal choices that aren't made in the
Doom module.

#+begin_src emacs-lisp
(use-package! emacs-everywhere
  :if (daemonp)
  :config
  (require 'spell-fu)
  (setq emacs-everywhere-major-mode-function #'org-mode
        emacs-everywhere-frame-name-format "Edit ∷ %s — %s")
  (defadvice! emacs-everywhere-raise-frame ()
    :after #'emacs-everywhere-set-frame-name
    (setq emacs-everywhere-frame-name (format emacs-everywhere-frame-name-format
                                (emacs-everywhere-app-class emacs-everywhere-current-app)
                                (truncate-string-to-width
                                 (emacs-everywhere-app-title emacs-everywhere-current-app)
                                 45 nil nil "…")))
    ;; need to wait till frame refresh happen before really set
    (run-with-timer 0.1 nil #'emacs-everywhere-raise-frame-1))
  (defun emacs-everywhere-raise-frame-1 ()
    (call-process "wmctrl" nil nil nil "-a" emacs-everywhere-frame-name)))
#+end_src

*** Which-key

#+call: confpkg("!Pkg which-key")

#+begin_quote
From the =:core packages= module.
#+end_quote

Let's make this popup a bit faster
#+begin_src emacs-lisp
(setq which-key-idle-delay 0.5) ;; I need the help, I really do
#+end_src

I also think that having =evil-= appear in so many popups is a bit too verbose,
let's change that, and do a few other similar tweaks while we're at it.
#+begin_src emacs-lisp
(setq which-key-allow-multiple-replacements t)
(after! which-key
  (pushnew!
   which-key-replacement-alist
   '(("" . "\\`+?evil[-:]?\\(?:a-\\)?\\(.*\\)") . (nil . "◂\\1"))
   '(("\\`g s" . "\\`evilem--?motion-\\(.*\\)") . (nil . "◃\\1"))
   ))
#+end_src

#+attr_html: :class invertible :alt Whichkey triggered on an evil motion
[[https://tecosaur.com/lfs/emacs-config/screenshots/whichkey-evil.png]]

** Tools
*** Abbrev

#+call: confpkg("Multi-mode abbrev")

Thanks to [[https://emacs.stackexchange.com/questions/45462/use-a-single-abbrev-table-for-multiple-modes/45476#45476][use a single abbrev-table for multiple modes? - Emacs Stack Exchange]] I
have the following.

#+begin_src emacs-lisp :tangle no
(add-hook 'doom-first-buffer-hook
          (defun +abbrev-file-name ()
            (setq-default abbrev-mode t)
            (setq abbrev-file-name (expand-file-name "abbrev.el" doom-private-dir))))
#+end_src

*** Very large files

#+call: confpkg("!Pkg VLF")

The /very large files/ mode loads large files in chunks, allowing one to open
ridiculously large files.

#+begin_src emacs-lisp :tangle packages.el
(package! vlf :recipe (:host github :repo "emacs-straight/vlf" :files ("*.el"))
  :pin "cacdb359f8c37c6e7e4c7937462b632d22462130")
#+end_src

To make VLF available without delaying startup, we'll just load it in quiet moments.

#+begin_src emacs-lisp :noweb no-export :noweb-prefix no
(use-package! vlf-setup
  :defer-incrementally vlf-tune vlf-base vlf-write
  vlf-search vlf-occur vlf-follow vlf-ediff vlf
  :commands vlf vlf-mode
  :init
  <<vlf-largefile-prompt>>
  :config
  (advice-remove 'abort-if-file-too-large #'ad-Advice-abort-if-file-too-large)
  <<vlf-linenum-offset>>
  <<vlf-search-chunking>>)
#+end_src

Now, there are one or two tweaks worth applying to VLF. For starters, it goes to
the liberty of advising ~abort-if-file-too-large~, and in doing so removes the
option of opening files literally. I think that's a bit much, so we can remove
the advice and instead override ~files--ask-user-about-large-file~ (the more
appropriate function, I think) as a simpler approach, just sacrificing the
original behaviour with src_elisp{(setq vlf-application 'always)} (which I can't
imagine using anyway).

#+name: vlf-largefile-prompt
#+begin_src emacs-lisp :noweb-ref none
(defadvice! +files--ask-about-large-file-vlf (size op-type filename offer-raw)
  "Like `files--ask-user-about-large-file', but with support for `vlf'."
  :override #'files--ask-user-about-large-file
  (if (eq vlf-application 'dont-ask)
      (progn (vlf filename) (error ""))
    (let ((prompt (format "File %s is large (%s), really %s?"
                          (file-name-nondirectory filename)
                          (funcall byte-count-to-string-function size) op-type)))
      (if (not offer-raw)
          (if (y-or-n-p prompt) nil 'abort)
        (let ((choice
               (car
                (read-multiple-choice
                 prompt '((?y "yes")
                          (?n "no")
                          (?l "literally")
                          (?v "vlf"))
                 (files--ask-user-about-large-file-help-text
                  op-type (funcall byte-count-to-string-function size))))))
          (cond ((eq choice ?y) nil)
                ((eq choice ?l) 'raw)
                ((eq choice ?v)
                 (vlf filename)
                 (error ""))
                (t 'abort)))))))
#+end_src

As you go from one chunk fetched by VLF to the next, the displayed line number
of the first line /in each chunk/ is unchanged. I think it's reasonable to hope
for an /overall/ line number, and by tracking chunk's cumulative line numbers we
can implement this behaviour fairly easily.

#+name: vlf-linenum-offset
#+begin_src emacs-lisp :noweb-ref none
(defvar-local +vlf-cumulative-linenum '((0 . 0))
  "An alist keeping track of the cumulative line number.")

(defun +vlf-update-linum ()
  "Update the line number offset."
  (let ((linenum-offset (alist-get vlf-start-pos +vlf-cumulative-linenum)))
    (setq display-line-numbers-offset (or linenum-offset 0))
    (when (and linenum-offset (not (assq vlf-end-pos +vlf-cumulative-linenum)))
      (push (cons vlf-end-pos (+ linenum-offset
                                 (count-lines (point-min) (point-max))))
            +vlf-cumulative-linenum))))

(add-hook 'vlf-after-chunk-update-hook #'+vlf-update-linum)

;; Since this only works with absolute line numbers, let's make sure we use them.
(add-hook! 'vlf-mode-hook (setq-local display-line-numbers t))
#+end_src

The other thing that doesn't work too well with VLF is searching with anything
other than =M-x occur=. This is because trying to go to the next match at the end
of a chunk usually wraps the point to the beginning of the chunk, instead of
moving to the next chunk.

#+name: vlf-search-chunking
#+begin_src emacs-lisp :noweb-ref none
(defun +vlf-next-chunk-or-start ()
  (if (= vlf-file-size vlf-end-pos)
      (vlf-jump-to-chunk 1)
    (vlf-next-batch 1))
  (goto-char (point-min)))

(defun +vlf-last-chunk-or-end ()
  (if (= 0 vlf-start-pos)
      (vlf-end-of-file)
    (vlf-prev-batch 1))
  (goto-char (point-max)))

(defun +vlf-isearch-wrap ()
  (if isearch-forward
      (+vlf-next-chunk-or-start)
    (+vlf-last-chunk-or-end)))

(add-hook! 'vlf-mode-hook (setq-local isearch-wrap-function #'+vlf-isearch-wrap))
#+end_src

Unfortunately, since evil-search doesn't have an analogue to
~isearch-wrap-function~, we can't easily add support to it.

*** Eros

#+call: confpkg("!Pkg Eros")

#+begin_quote
From the =:tools eval= module.
#+end_quote

This package enables the very nice inline evaluation with =gr= and =gR=. The prefix
could be slightly nicer though.
#+begin_src emacs-lisp
(setq eros-eval-result-prefix "⟹ ") ; default =>
#+end_src

*** EVIL

#+call: confpkg("!Pkg evil")

#+begin_quote
From the =:editor evil= module.
#+end_quote

When I want to make a substitution, I want it to be global more often than not
--- so let's make that the default.

Now, EVIL cares a fair bit about keeping compatibility with Vim's default
behaviour. I don't. There are some particular settings that I'd rather be
something else, so let's change them.

#+begin_src emacs-lisp
(after! evil
  (setq evil-ex-substitute-global t     ; I like my s/../.. to by global by default
        evil-move-cursor-back nil       ; Don't move the block cursor when toggling insert mode
        evil-kill-on-visual-paste nil)) ; Don't put overwritten text in the kill ring
#+end_src

I don't use ~evil-escape-mode~, so I may as well turn it off, I've heard it
contributes a typing delay. I'm not sure it's much, but it is an extra
~pre-command-hook~ that I don't benefit from, so...
It seems that there's a dedicated package for this, so instead of just disabling
the mode on startup, let's prevent installation of the package.

#+begin_src emacs-lisp :tangle packages.el :noweb-ref none
(package! evil-escape :disable t)
#+end_src

*** Consult

#+call: confpkg("!Pkg Consult")

#+begin_quote
From the =:completion vertico= module.
#+end_quote

Since we're using [[Marginalia]] too, the separation between buffers and files is
already clear, and there's no need for a different face.

#+begin_src emacs-lisp
(after! consult
  (set-face-attribute 'consult-file nil :inherit 'consult-buffer)
  (setf (plist-get (alist-get 'perl consult-async-split-styles-alist) :initial) ";"))
#+end_src

*** Magit

#+call: confpkg("!Pkg Magit")

#+begin_quote
From the =:tools magit= module.
#+end_quote

[[xkcd:1597]]

Magit is great as-is, thanks for making such a lovely package [[https://github.com/tarsius][Jonas]]!

There's still a room for a little tweaking though...

#+begin_src emacs-lisp :noweb no-export :noweb-prefix no
<<magit-toplevel>>
(after! magit
  <<magit-tweaks>>)
#+end_src

**** Easier forge remotes
:PROPERTIES:
:header-args:emacs-lisp: :noweb-ref magit-tweaks
:END:

When creating a new project, I often want the remote to be to my personal gitea
instance. Let's make that a bit more streamlined by introducing a quick-entry
"default forge" option.

#+begin_src emacs-lisp
(defvar +magit-default-forge-remote "gitea@git.tecosaur.net:tec/%s.git"
  "Format string that fills out to a remote from the repo name.
Set to nil to disable this functionality.")
#+end_src

While we're at it, when creating a remote with the same name as my github
username in a project where an https github remote already exists, let's make
the pre-filled remote url use ssh.

#+begin_src emacs-lisp
(defadvice! +magit-remote-add--streamline-forge-a (args)
  :filter-args #'magit-remote-add
  (interactive
   (or (and +magit-default-forge-remote
            (not (magit-list-remotes))
            (eq (read-char-choice
                 (format "Setup %s remote? [y/n]: "
                         (replace-regexp-in-string
                          "\\`\\(?:[^@]+@\\|https://\\)\\([^:/]+\\)[:/].*\\'" "\\1"
                          +magit-default-forge-remote))
                 '(?y ?n))
                ?y)
            (let* ((default-name
                     (subst-char-in-string ?\s ?-
                                           (file-name-nondirectory
                                            (directory-file-name (doom-project-root)))))
                   (name (read-string "Name: " default-name)))
              (list "origin" (format +magit-default-forge-remote name)
                    (transient-args 'magit-remote))))
       (let ((origin (magit-get "remote.origin.url"))
             (remote (magit-read-string-ns "Remote name"))
             (gh-user (magit-get "github.user")))
         (when (and (equal remote gh-user)
                    (string-match "\\`https://github\\.com/\\([^/]+\\)/\\([^/]+\\)\\.git\\'"
                                  origin)
                    (not (string= (match-string 1 origin) gh-user)))
           (setq origin (replace-regexp-in-string
                         "\\`https://github\\.com/" "git@github.com:"
                         origin)))
         (list remote
               (magit-read-url
                "Remote url"
                (and origin
                     (string-match "\\([^:/]+\\)/[^/]+\\(\\.git\\)?\\'" origin)
                     (replace-match remote t t origin 1)))
               (transient-args 'magit-remote)))))
  args)
#+end_src

**** Commit message templates
:PROPERTIES:
:header-args:emacs-lisp: :noweb-ref magit-tweaks
:END:

One little thing I want to add is some per-project commit message templates.

#+begin_src emacs-lisp :noweb-ref magit-toplevel
(defvar +magit-project-commit-templates-alist nil
  "Alist of toplevel dirs and template hf strings/functions.")
#+end_src

#+begin_src emacs-lisp
(defun +magit-fill-in-commit-template ()
  "Insert template from `+magit-fill-in-commit-template' if applicable."
  (when-let ((template (and (save-excursion (goto-char (point-min)) (string-match-p "\\`\\s-*$" (thing-at-point 'line)))
                            (cdr (assoc (file-name-base (directory-file-name (magit-toplevel)))
                                        +magit-project-commit-templates-alist)))))
    (goto-char (point-min))
    (insert (if (stringp template) template (funcall template)))
    (goto-char (point-min))
    (end-of-line)))
(add-hook 'git-commit-setup-hook #'+magit-fill-in-commit-template 90)
#+end_src

This is particularly useful when creating commits for Org, as they need to
follow [[https://orgmode.org/worg/org-contribute.html#commit-messages][a certain format]] and sometimes I forget elements (oops!).
#+begin_src emacs-lisp
(defun +org-commit-message-template ()
  "Create a skeleton for an Org commit message based on the staged diff."
  (let (change-data last-file file-changes temp-point)
    (with-temp-buffer
      (apply #'call-process magit-git-executable
             nil t nil
             (append
              magit-git-global-arguments
              (list "diff" "--cached")))
      (goto-char (point-min))
      (while (re-search-forward "^@@\\|^\\+\\+\\+ b/" nil t)
        (if (looking-back "^\\+\\+\\+ b/" (line-beginning-position))
            (progn
              (push (list last-file file-changes) change-data)
              (setq last-file (buffer-substring-no-properties (point) (line-end-position))
                    file-changes nil))
          (setq temp-point (line-beginning-position))
          (re-search-forward "^\\+\\|^-" nil t)
          (end-of-line)
          (cond
           ((string-match-p "\\.el$" last-file)
            (when (re-search-backward "^\\(?:[+-]? *\\|@@[ +-\\d,]+@@ \\)(\\(?:cl-\\)?\\(?:defun\\|defvar\\|defmacro\\|defcustom\\)" temp-point t)
              (re-search-forward "\\(?:cl-\\)?\\(?:defun\\|defvar\\|defmacro\\|defcustom\\) " nil t)
              (add-to-list 'file-changes (buffer-substring-no-properties (point) (forward-symbol 1)))))
           ((string-match-p "\\.org$" last-file)
            (when (re-search-backward "^[+-]\\*+ \\|^@@[ +-\\d,]+@@ \\*+ " temp-point t)
              (re-search-forward "@@ \\*+ " nil t)
              (add-to-list 'file-changes (buffer-substring-no-properties (point) (line-end-position)))))))))
    (push (list last-file file-changes) change-data)
    (setq change-data (delete '(nil nil) change-data))
    (concat
     (if (= 1 (length change-data))
         (replace-regexp-in-string "^.*/\\|.[a-z]+$" "" (caar change-data))
       "?")
     ": \n\n"
     (mapconcat
      (lambda (file-changes)
        (if (cadr file-changes)
            (format "* %s (%s): "
                    (car file-changes)
                    (mapconcat #'identity (cadr file-changes) ", "))
          (format "* %s: " (car file-changes))))
      change-data
      "\n\n"))))

(add-to-list '+magit-project-commit-templates-alist (cons "org" #'+org-commit-message-template))
#+end_src

This relies on two small entries in the git config files which improves the hunk
heading line selection for elisp and Org files.

#+begin_src gitconfig
[diff "lisp"]
  xfuncname = "^(((;;;+ )|\\(|([ \t]+\\(((cl-|el-patch-)?def(un|var|macro|method|custom)|gb/))).*)$"

[diff "org"]
  xfuncname = "^(\\*+ +.*)$"
#+end_src

**** Magit delta

[[https://github.com/dandavison/delta/][Delta]] is a git diff syntax highlighter written in rust. The author also wrote a
package to hook this into the magit diff view (which don't get any syntax
highlighting by default). This requires the ~delta~ binary. It's packaged on some
distributions, but most reliably installed through Rust's package manager cargo.

#+begin_src shell :eval no :tangle (if (or (not (executable-find "cargo")) (executable-find "delta")) "no" "setup.sh")
cargo install git-delta
#+end_src

Now we can make use of the package for this.
#+begin_src emacs-lisp :tangle packages.el :noweb-ref none
;; (package! magit-delta :recipe (:host github :repo "dandavison/magit-delta") :pin "5fc7dbddcfacfe46d3fd876172ad02a9ab6ac616")
#+end_src

All that's left is to hook it into magit
#+begin_src emacs-lisp :noweb-ref none
;; (magit-delta-mode +1)
#+end_src
Unfortunately this currently seems to mess things up, which is something I'll
want to look into later.

*** Smerge

#+call: confpkg("!Pkg Smerge")

For repeated operations, a hydra would be helpful. But I prefer transient.
#+begin_src emacs-lisp
(defun smerge-repeatedly ()
  "Perform smerge actions again and again"
  (interactive)
  (smerge-mode 1)
  (smerge-transient))
(after! transient
  (transient-define-prefix smerge-transient ()
    [["Move"
      ("n" "next" (lambda () (interactive) (ignore-errors (smerge-next)) (smerge-repeatedly)))
      ("p" "previous" (lambda () (interactive) (ignore-errors (smerge-prev)) (smerge-repeatedly)))]
     ["Keep"
      ("b" "base" (lambda () (interactive) (ignore-errors (smerge-keep-base)) (smerge-repeatedly)))
      ("u" "upper" (lambda () (interactive) (ignore-errors (smerge-keep-upper)) (smerge-repeatedly)))
      ("l" "lower" (lambda () (interactive) (ignore-errors (smerge-keep-lower)) (smerge-repeatedly)))
      ("a" "all" (lambda () (interactive) (ignore-errors (smerge-keep-all)) (smerge-repeatedly)))
      ("RET" "current" (lambda () (interactive) (ignore-errors (smerge-keep-current)) (smerge-repeatedly)))]
     ["Diff"
      ("<" "upper/base" (lambda () (interactive) (ignore-errors (smerge-diff-base-upper)) (smerge-repeatedly)))
      ("=" "upper/lower" (lambda () (interactive) (ignore-errors (smerge-diff-upper-lower)) (smerge-repeatedly)))
      (">" "base/lower" (lambda () (interactive) (ignore-errors (smerge-diff-base-lower)) (smerge-repeatedly)))
      ("R" "refine" (lambda () (interactive) (ignore-errors (smerge-refine)) (smerge-repeatedly)))
      ("E" "ediff" (lambda () (interactive) (ignore-errors (smerge-ediff)) (smerge-repeatedly)))]
     ["Other"
      ("c" "combine" (lambda () (interactive) (ignore-errors (smerge-combine-with-next)) (smerge-repeatedly)))
      ("r" "resolve" (lambda () (interactive) (ignore-errors (smerge-resolve)) (smerge-repeatedly)))
      ("k" "kill current" (lambda () (interactive) (ignore-errors (smerge-kill-current)) (smerge-repeatedly)))
      ("q" "quit" (lambda () (interactive) (smerge-auto-leave)))]]))
#+end_src

*** Company

#+call: confpkg("!Pkg Company")

#+begin_quote
From the =:completion company= module.
#+end_quote

It's nice to have completions almost all the time, in my opinion. Key strokes
are just waiting to be saved!

#+begin_src emacs-lisp
(after! company
  (setq company-idle-delay 0.5
        company-minimum-prefix-length 2)
  (setq company-show-numbers t)
  (add-hook 'evil-normal-state-entry-hook #'company-abort)) ;; make aborting less annoying.
#+end_src

Now, the improvements from ~precedent~ are mostly from remembering history, so
let's improve that memory.

#+begin_src emacs-lisp
(setq-default history-length 1000)
(setq-default prescient-history-length 1000)
#+end_src

**** Plain Text

~Ispell~ is nice, let's have it in ~text~, ~markdown~, and ~GFM~.
#+begin_src emacs-lisp
(set-company-backend!
  '(text-mode
    markdown-mode
    gfm-mode)
  '(:seperate
    company-ispell
    company-files
    company-yasnippet))
#+end_src
We then configure the dictionary we're using in [[*Ispell][Ispell]].

**** ESS

~company-dabbrev-code~ is nice. Let's have it.
#+begin_src emacs-lisp
(set-company-backend! 'ess-r-mode '(company-R-args company-R-objects company-dabbrev-code :separate))
#+end_src

*** Projectile

#+call: confpkg("!Pkg Projectile")

#+begin_quote
From the =:core packages= module.
#+end_quote

Looking at documentation via =SPC h f= and =SPC h v= and looking at the source can
add package src directories to projectile. This isn't desirable in my opinion.

#+begin_src emacs-lisp
(setq projectile-ignored-projects
      (list "~/" "/tmp" (expand-file-name "straight/repos" doom-local-dir)))
(defun projectile-ignored-project-function (filepath)
  "Return t if FILEPATH is within any of `projectile-ignored-projects'"
  (or (mapcar (lambda (p) (s-starts-with-p p filepath)) projectile-ignored-projects)))
#+end_src

*** Ispell
**** Downloading dictionaries

Let's get a nice big dictionary from [[http://app.aspell.net/create][SCOWL Custom List/Dictionary Creator]] with
the following configuration
- size :: 80 (huge)
- spellings :: British(-ise) and Australian
- spelling variants level :: 0
- diacritics :: keep
- extra lists :: hacker, roman numerals

***** Hunspell

#+begin_src shell :tangle (if (file-exists-p "/usr/share/myspell/en-custom.dic") "no" "setup.sh")
cd /tmp
curl -o "hunspell-en-custom.zip" 'http://app.aspell.net/create?max_size=80&spelling=GBs&spelling=AU&max_variant=0&diacritic=keep&special=hacker&special=roman-numerals&encoding=utf-8&format=inline&download=hunspell'
unzip "hunspell-en-custom.zip"

sudo chown root:root en-custom.*
sudo mv en-custom.{aff,dic} /usr/share/myspell/
#+end_src

***** Aspell

#+begin_src shell :tangle (if (file-expand-wildcards "/usr/lib64/aspell*/en-custom.multi") "no" "setup.sh")
cd /tmp
curl -o "aspell6-en-custom.tar.bz2" 'http://app.aspell.net/create?max_size=80&spelling=GBs&spelling=AU&max_variant=0&diacritic=keep&special=hacker&special=roman-numerals&encoding=utf-8&format=inline&download=aspell'
tar -xjf "aspell6-en-custom.tar.bz2"

cd aspell6-en-custom
./configure && make && sudo make install
#+end_src

**** Configuration

#+call: confpkg("!Pkg Ispell")

#+begin_src emacs-lisp
(setq ispell-dictionary "en-custom")
#+end_src

Oh, and by the way, if ~company-ispell-dictionary~ is ~nil~, then
~ispell-complete-word-dict~ is used instead, which once again when ~nil~ is
~ispell-alternate-dictionary~, which at the moment maps to a plaintext version of
the above.

It seems reasonable to want to keep an eye on my personal dict, let's have it
nearby (also means that if I change the 'main' dictionary I keep my addition).

#+begin_src emacs-lisp
(setq ispell-personal-dictionary
      (expand-file-name "misc/ispell_personal" doom-private-dir))
#+end_src

*** TRAMP

#+call: confpkg("TRAMP")

Another lovely Emacs feature, TRAMP stands for /Transparent Remote Access,
Multiple Protocol/. In brief, it's a lovely way to wander around outside your
local filesystem.

**** Prompt recognition

Unfortunately, when connecting to remote machines Tramp can be a wee pit picky
with the prompt format. Let's try to get Bash, and be a bit more permissive with
prompt recognition.

#+begin_src emacs-lisp
(after! tramp
  (setenv "SHELL" "/bin/bash")
  (setq tramp-shell-prompt-pattern "\\(?:^\\|\n\\|\x0d\\)[^]#$%>\n]*#?[]#$%>] *\\(\e\\[[0-9;]*[a-zA-Z] *\\)*")) ;; default + 
#+end_src

**** Troubleshooting

In case the remote shell is misbehaving, here are some things to try

***** Zsh

There are some escape code you don't want, let's make it behave more considerately.
#+begin_src shell :eval no :tangle no
if [[ "$TERM" == "dumb" ]]; then
    unset zle_bracketed_paste
    unset zle
    PS1='$ '
    return
fi
#+end_src

**** Guix

[[https://guix.gnu.org/][Guix]] puts some binaries that TRAMP looks for in unexpected locations.
That's no problem though, we just need to help TRAMP find them.

#+begin_src emacs-lisp
(after! tramp
  (appendq! tramp-remote-path
            '("~/.guix-profile/bin" "~/.guix-profile/sbin"
              "/run/current-system/profile/bin"
              "/run/current-system/profile/sbin")))
#+end_src

*** Auto activating snippets

#+call: confpkg("!Pkg AAS")

Sometimes pressing =TAB= is just too much.
#+begin_src emacs-lisp :tangle packages.el
(package! aas :recipe (:host github :repo "ymarco/auto-activating-snippets")
  :pin "e92b5cffa4e87c221c24f3e72ae33959e1ec2b68")
#+end_src

#+begin_src emacs-lisp
(use-package! aas
  :commands aas-mode)
#+end_src

*** Screenshot

#+call: confpkg("!Pkg Screenshot")

This makes it a breeze to take lovely screenshots.

#+begin_src emacs-lisp :tangle packages.el
(package! screenshot :recipe (:local-repo "lisp/screenshot"))
#+end_src

#+attr_html: :class invertible :alt Example screenshot.el screenshot
[[https://tecosaur.com/lfs/emacs-config/screenshots/screenshot.png]]

Some light configuring is all we need, so we can make use of the [[https://github.com/Calinou/0x0][0x0]] wrapper
file uploading script (which I've renamed to ~upload~).

#+begin_src emacs-lisp
(use-package! screenshot
  :defer t
  :config (setq screenshot-upload-fn "upload %s 2>/dev/null"))
#+end_src

*** Etrace

#+call: confpkg("!Pkg etrace")

The /Emacs Lisp Profiler/ (ELP) does a nice job recording information, but it
isn't the best for looking at results. =etrace= converts ELP's results to the
"Chromium Catapult Trace Event Format". This means that the output of =etrace= can
be loaded in something like the [[https://www.speedscope.app/][speedscope]] webapp for easier profile
investigation.

#+begin_src emacs-lisp :tangle packages.el
(package! etrace :recipe (:host github :repo "aspiers/etrace")
  :pin "2291ccf2f2ccc80a6aac4664e8ede736ceb672b7")
#+end_src

#+begin_src emacs-lisp
(use-package! etrace
  :after elp)
#+end_src

*** YASnippet

#+call: confpkg("!Pkg YASnippet")

#+begin_quote
From the =:editor snippets= module.
#+end_quote

Nested snippets are good, so let's enable that.
#+begin_src emacs-lisp
(setq yas-triggers-in-field t)
#+end_src

*** String inflection

#+call: confpkg("!Pkg String Inflection")

For when you want to change the case pattern for a symbol.
#+begin_src emacs-lisp :tangle packages.el
(package! string-inflection :pin "50ad54970b3cc79b6b83979bde9889ad9a9e1a9c")
#+end_src

#+begin_src emacs-lisp
(use-package! string-inflection
  :commands (string-inflection-all-cycle
             string-inflection-toggle
             string-inflection-camelcase
             string-inflection-lower-camelcase
             string-inflection-kebab-case
             string-inflection-underscore
             string-inflection-capital-underscore
             string-inflection-upcase)
  :init
  (map! :leader :prefix ("c~" . "naming convention")
        :desc "cycle" "~" #'string-inflection-all-cycle
        :desc "toggle" "t" #'string-inflection-toggle
        :desc "CamelCase" "c" #'string-inflection-camelcase
        :desc "downCase" "d" #'string-inflection-lower-camelcase
        :desc "kebab-case" "k" #'string-inflection-kebab-case
        :desc "under_score" "_" #'string-inflection-underscore
        :desc "Upper_Score" "u" #'string-inflection-capital-underscore
        :desc "UP_CASE" "U" #'string-inflection-upcase)
  (after! evil
    (evil-define-operator evil-operator-string-inflection (beg end _type)
      "Define a new evil operator that cycles symbol casing."
      :move-point nil
      (interactive "<R>")
      (string-inflection-all-cycle)
      (setq evil-repeat-info '([?g ?~])))
    (define-key evil-normal-state-map (kbd "g~") 'evil-operator-string-inflection)))
#+end_src

*** Smart parentheses

#+call: confpkg("!Pkg SmartParens")

#+begin_quote
From the =:core packages= module.
#+end_quote

#+begin_src emacs-lisp
(sp-local-pair
 '(org-mode)
 "<<" ">>"
 :actions '(insert))
#+end_src

** #Visuals
# *** Info colours

# #+call: confpkg("!Pkg Info colors")

# This makes manual pages nicer to look at by adding variable pitch fontification
# and colouring 🙂.

# #+attr_html: :class invertible :style width:80% :alt Example info-colours page.
# [[https://tecosaur.com/lfs/emacs-config/screenshots/info-colours.png]]

# #+begin_src emacs-lisp :tangle packages.el
# (package! info-colors :pin "2e237c301ba62f0e0286a27c1abe48c4c8441143")
# #+end_src

# To use this we'll just hook it into =Info=.

# #+begin_src emacs-lisp
# (use-package! info-colors
#   :commands (info-colors-fontify-node))

# (add-hook 'Info-selection-hook 'info-colors-fontify-node)
# #+end_src

# #+attr_html: :class invertible :alt Example colourised info page
# [[https://tecosaur.com/lfs/emacs-config/screenshots/info-coloured.png]]

# *** Modus themes

# Proteolas did a lovely job with the Modus themes, so much so that they were
# welcomed into Emacs 28. However, he is also rather attentive with updates, and
# so I'd like to make sure we have a recent version.

# #+begin_src emacs-lisp :tangle packages.el
# (package! modus-themes :pin "18dd2457d233859ad4d102d797d6744525177ac4")
# #+end_src

# *** Spacemacs themes

# #+begin_src emacs-lisp :tangle packages.el
# (package! spacemacs-theme :pin "1ec73d68b0f120f92538d9a329a3a46e32f74510")
# #+end_src

# *** Theme magic

# #+call: confpkg("!Pkg Theme magic")

# With all our fancy Emacs themes, my terminal is missing out!
# #+begin_src emacs-lisp :tangle packages.el
# (package! theme-magic :pin "844c4311bd26ebafd4b6a1d72ddcc65d87f074e3")
# #+end_src

# This operates using =pywal=, which is present in some repositories, but most
# reliably installed with =pip=.
# #+begin_src shell :eval no :tangle (if (executable-find "wal") "no" "setup.sh")
# sudo python3 -m pip install pywal
# #+end_src

# Theme magic takes a look at a number of faces, the saturation levels, and colour
# differences to try to cleverly pick eight colours to use. However, it uses the
# same colours for the light variants, and doesn't always make the best picks.
# Since we're using =doom-themes=, our life is a little easier and we can use the
# colour utilities from Doom themes to easily grab sensible colours and generate
# lightened versions --- let's do that.

# #+begin_src emacs-lisp
# (use-package! theme-magic
#   :commands theme-magic-from-emacs
#   :config
#   (defadvice! theme-magic--auto-extract-16-doom-colors ()
#     :override #'theme-magic--auto-extract-16-colors
#     (list
#      (face-attribute 'default :background)
#      (doom-color 'error)
#      (doom-color 'success)
#      (doom-color 'type)
#      (doom-color 'keywords)
#      (doom-color 'constants)
#      (doom-color 'functions)
#      (face-attribute 'default :foreground)
#      (face-attribute 'shadow :foreground)
#      (doom-blend 'base8 'error 0.1)
#      (doom-blend 'base8 'success 0.1)
#      (doom-blend 'base8 'type 0.1)
#      (doom-blend 'base8 'keywords 0.1)
#      (doom-blend 'base8 'constants 0.1)
#      (doom-blend 'base8 'functions 0.1)
#      (face-attribute 'default :foreground))))
# #+end_src

# *** Simple comment markup

# #+call: confpkg("!Pkg simple-comment-markup")

# I find that every now and then I sprinkle a little markup in code comments. Of
# course, this doesn't get fortified as it's ultimately meaningless ... but it
# would be nice if it was, just slightly. Surprisingly, I couldn't find a package
# for this, so I made one.

# #+begin_src emacs-lisp :tangle packages.el
# (package! simple-comment-markup :recipe (:local-repo "lisp/simple-comment-markup"))
# #+end_src

# Let's use both basic Org markup and Markdown code backticks, to cover most
# situations decently.

# #+begin_src emacs-lisp
# (use-package! simple-comment-markup
#   :hook (prog-mode . simple-comment-markup-mode)
#   :config
#   (setq simple-comment-markup-set '(org markdown-code)))
# #+end_src

# *** Doom modeline

# #+call: confpkg("!Pkg Doom modeline", after="doom-modeline")

# #+begin_quote
# From the =:ui modeline= module.
# #+end_quote

# **** Modified buffer colour

# The modeline is very nice and pretty, however I have a few niggles with the
# defaults. For starters, by default ~red~ text is used to indicate an unsaved file.
# This makes me feel like something's gone /wrong/, so let's tone that down to
# orange.

# #+begin_src emacs-lisp
# (custom-set-faces!
#   '(doom-modeline-buffer-modified :foreground "orange"))
# #+end_src

# **** Height

# The default size (=25=) makes for a rather narrow mode line. To me, the modeline
# feels a bit comfier if we give it a bit more space. I find =45= adds roughly a
# third of the line height as padding above and below.

# #+begin_src emacs-lisp
# (setq doom-modeline-height 45)
# #+end_src

# **** File encoding

# While we're modifying the modeline, when we have the default file encoding (=LF
# UTF-8=), it really isn't worth noting in the modeline. So, why not conditionally
# hide it?

# #+begin_src emacs-lisp
# (defun doom-modeline-conditional-buffer-encoding ()
#   "We expect the encoding to be LF UTF-8, so only show the modeline when this is not the case"
#   (setq-local doom-modeline-buffer-encoding
#               (unless (and (memq (plist-get (coding-system-plist buffer-file-coding-system) :category)
#                                  '(coding-category-undecided coding-category-utf-8))
#                            (not (memq (coding-system-eol-type buffer-file-coding-system) '(1 2))))
#                 t)))

# (add-hook 'after-change-major-mode-hook #'doom-modeline-conditional-buffer-encoding)
# #+end_src

# **** Time

# Moving onto the modeline segments, there's a calendar icon showed next to the
# current time, which I'm not a fan of. Let's replace that by redefining the
# segment. Instead of the calendar, it would be much nicer to have an updating
# analog clock, so let's use that idea as an excuse to try out the Emacs svg library.

# First, we'll need a way to produce svg clocks on-demand.

# #+begin_src emacs-lisp
# (defvar micro-clock-hour-hand-ratio 0.45
#   "Length of the hour hand as a proportion of the radius.")
# (defvar micro-clock-minute-hand-ratio 0.7
#   "Length of the minute hand as a proportion of the radius.")

# (defun micro-clock-svg (hour minute radius color)
#   "Construct an SVG clock showing the time HOUR:MINUTE.
# The clock will be of the specified RADIUS and COLOR."
#   (let ((hour-x (* radius (sin (* (- 6 hour (/ minute 60.0)) (/ float-pi 6)))
#                    micro-clock-hour-hand-ratio))
#         (hour-y (* radius (cos (* (- 6 hour (/ minute 60.0)) (/ float-pi 6)))
#                    micro-clock-hour-hand-ratio))
#         (minute-x (* radius (sin (* (- 30 minute) (/ float-pi 30)))
#                      micro-clock-minute-hand-ratio))
#         (minute-y (* radius (cos (* (- 30 minute) (/ float-pi 30)))
#                      micro-clock-minute-hand-ratio))
#         (svg (svg-create (* 2 radius) (* 2 radius) :stroke color)))
#     (svg-circle svg radius radius (1- radius) :fill "none" :stroke-width 2)
#     (svg-circle svg radius radius 1 :fill color :stroke "none")
#     (svg-line svg radius radius (+ radius hour-x) (+ radius hour-y)
#               :stroke-width 2)
#     (svg-line svg radius radius (+ radius minute-x) (+ radius minute-y)
#               :stroke-width 1.5)
#     svg))
# #+end_src

# With that out the way, we need to figure out how to integrate this into the
# modeline. For the most part this was fairly easy, the tricky part was getting
# the alignment right. I tried using the =(raise FACTOR)= display property, but that
# doesn't appear to combine with images. Looking at the documentation on [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Image-Descriptors.html][image
# descriptors]] though, I came across the =:ascent= property, which looked rather
# promising. By setting =:ascent center= the image is centred relative to the text,
# which is exactly what we need. With that sorted, we just add some caching and
# the obvious customisations and we've got modeline-appropriate clock generation!

# #+begin_src emacs-lisp
# (require 'svg)

# (defvar +doom-modeline-micro-clock-minute-resolution 1
#   "The clock will be updated every this many minutes, truncating.")
# (defvar +doom-modeline-micro-clock-inverse-size 4.8
#   "The size of the clock, as an inverse proportion to the mode line height.")

# (defvar +doom-modeline-micro-clock--cache nil)

# (defvar +doom-modeline-clock-text-format "%c")

# (defun +doom-modeline--clock-text (&optional _window _object _pos)
#   (format-time-string +doom-modeline-clock-text-format))

# (defun +doom-modeline-micro-clock ()
#   "Return a string containing an current analogue clock."
#   (cdr
#    (if (equal (truncate (float-time)
#                         (* +doom-modeline-micro-clock-minute-resolution 60))
#               (car +doom-modeline-micro-clock--cache))
#        +doom-modeline-micro-clock--cache
#      (setq +doom-modeline-micro-clock--cache
#            (cons (truncate (float-time)
#                            (* +doom-modeline-micro-clock-minute-resolution 60))
#                  (with-temp-buffer
#                    (svg-insert-image
#                     (micro-clock-svg
#                      (string-to-number (format-time-string "%-I")) ; hour
#                      (* (truncate (string-to-number (format-time-string "%-M"))
#                                   +doom-modeline-micro-clock-minute-resolution)
#                         +doom-modeline-micro-clock-minute-resolution) ; minute
#                      (/ doom-modeline-height +doom-modeline-micro-clock-inverse-size) ; radius
#                      "currentColor"))
#                    (propertize
#                     " "
#                     'display
#                     (append (get-text-property 0 'display (buffer-string))
#                             '(:ascent center))
#                     'face 'doom-modeline-time
#                     'help-echo #'+doom-modeline--clock-text)))))))
# #+end_src

# With clock generation sorted out, all that's to be done is replacing the =time=
# modeline segment with our design.

# #+begin_src emacs-lisp
# (doom-modeline-def-segment time
#   (when (and doom-modeline-time
#              (bound-and-true-p display-time-mode)
#              (not doom-modeline--limited-width-p))
#     (concat
#      doom-modeline-spc
#      (when doom-modeline-time-icon
#        (concat
#         (+doom-modeline-micro-clock)
#         (and (or doom-modeline-icon doom-modeline-unicode-fallback)
#              doom-modeline-spc)))
#      (propertize display-time-string
#                  'face (doom-modeline-face 'doom-modeline-time)))))
# #+end_src

# **** PDF modeline

# I think the PDF modeline could do with tweaking. I raised [[https://github.com/seagle0128/doom-modeline/pull/425][an issue]] on this,
# however the response was basically "put your preferences in your personal
# config, the current default is sensible" --- so here we are.

# First up I'm going to want a segment for just the buffer file name, and a PDF
# icon. Then we'll redefine two functions used to generate the modeline.

# #+begin_src emacs-lisp
# (doom-modeline-def-segment buffer-name
#   "Display the current buffer's name, without any other information."
#   (concat
#    doom-modeline-spc
#    (doom-modeline--buffer-name)))

# (doom-modeline-def-segment pdf-icon
#   "PDF icon from nerd-icons."
#   (concat
#    doom-modeline-spc
#    (doom-modeline-icon sucicon "nf-seti-pdf" nil nil
#                        :face (if (doom-modeline--active)
#                                  'nerd-icons-red
#                                'mode-line-inactive)
#                        :v-adjust 0.02)))

# (defun doom-modeline-update-pdf-pages ()
#   "Update PDF pages."
#   (setq doom-modeline--pdf-pages
#         (let ((current-page-str (number-to-string (eval `(pdf-view-current-page))))
#               (total-page-str (number-to-string (pdf-cache-number-of-pages))))
#           (concat
#            (propertize
#             (concat (make-string (- (length total-page-str) (length current-page-str)) ? )
#                     " P" current-page-str)
#             'face 'mode-line)
#            (propertize (concat "/" total-page-str) 'face 'doom-modeline-buffer-minor-mode)))))

# (doom-modeline-def-segment pdf-pages
#   "Display PDF pages."
#   (if (doom-modeline--active) doom-modeline--pdf-pages
#     (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

# (doom-modeline-def-modeline 'pdf
#   '(bar window-number pdf-pages pdf-icon buffer-name)
#   '(misc-info matches major-mode process vcs))
# #+end_src

# *** Keycast

# #+call: confpkg("!Pkg Keycast")

# For some reason, I find myself demoing Emacs every now and then. Showing what
# keyboard stuff I'm doing on-screen seems helpful. While [[https://gitlab.com/screenkey/screenkey][screenkey]] does exist,
# having something that doesn't cover up screen content is nice.

# #+attr_html: :class invertible :alt Screenshot of Keycast-mode in action
# [[https://tecosaur.com/lfs/emacs-config/screenshots/keycast.png]]

# #+begin_src emacs-lisp :tangle packages.el
# (package! keycast :pin "72d9add8ba16e0cae8cfcff7fc050fa75e493b4e")
# #+end_src

# Let's just make sure this is lazy-loaded appropriately.
# #+begin_src emacs-lisp
# (use-package! keycast
#   :commands keycast-mode
#   :config
#   (define-minor-mode keycast-mode
#     "Show current command and its key binding in the mode line."
#     :global t
#     (if keycast-mode
#         (progn
#           (add-hook 'pre-command-hook 'keycast--update t)
#           (add-to-list 'global-mode-string '("" mode-line-keycast " ")))
#       (remove-hook 'pre-command-hook 'keycast--update)
#       (setq global-mode-string (remove '("" mode-line-keycast " ") global-mode-string))))
#   (custom-set-faces!
#     '(keycast-command :inherit doom-modeline-debug
#                       :height 0.9)
#     '(keycast-key :inherit custom-modified
#                   :height 1.1
#                   :weight bold)))
# #+end_src

# *** Screencast

# #+call: confpkg("!Pkg Screencast")

# In a similar manner to [[Keycast]], [[https://gitlab.com/ambrevar/emacs-gif-screencast][gif-screencast]] may come in handy.
# #+begin_src emacs-lisp :tangle packages.el
# (package! gif-screencast :pin "adec408e6adab2e8e057fe0ad828749f473bfb83")
# #+end_src

# We can lazy load this using the start/stop commands.

# I initially installed ~scrot~ for this, since it was the default capture program.
# However it raised ~glib error: Saving to file ... failed~ each time it was run.
# Google didn't reveal any easy fixed, so I switched to [[https://github.com/naelstrof/maim][maim]]. We now need to pass
# it the window ID. This doesn't change throughout the lifetime of an emacs
# instance, so as long as a single window is used ~xdotool getactivewindow~ will
# give a satisfactory result.

# It seems that when new colours appear, that tends to make ~gifsicle~ introduce
# artefacts. To avoid this we pre-populate the colour map using the current doom
# theme.
# #+begin_src emacs-lisp
# (use-package! gif-screencast
#   :commands gif-screencast-mode
#   :config
#   (map! :map gif-screencast-mode-map
#         :g "<f8>" #'gif-screencast-toggle-pause
#         :g "<f9>" #'gif-screencast-stop)
#   (setq gif-screencast-program "maim"
#         gif-screencast-args `("--quality" "3" "-i" ,(string-trim-right
#                                                      (shell-command-to-string
#                                                       "xdotool getactivewindow")))
#         gif-screencast-optimize-args '("--batch" "--optimize=3" "--usecolormap=/tmp/doom-color-theme"))
#   (defun gif-screencast-write-colormap ()
#     (f-write-text
#      (replace-regexp-in-string
#       "\n+" "\n"
#       (mapconcat (lambda (c) (if (listp (cdr c))
#                                  (cadr c))) doom-themes--colors "\n"))
#      'utf-8
#      "/tmp/doom-color-theme" ))
#   (gif-screencast-write-colormap)
#   (add-hook 'doom-load-theme-hook #'gif-screencast-write-colormap))
# #+end_src

# *** Mixed pitch

# #+call: confpkg("!Pkg mixed pitch")

# #+begin_quote
# From the =:ui zen= module.
# #+end_quote

# We'd like to use mixed pitch in certain modes. If we simply add a hook, when
# directly opening a file with (a new) Emacs =mixed-pitch-mode= runs before UI
# initialisation, which is problematic. To resolve this, we create a hook that
# runs after UI initialisation and both
# + conditionally enables =mixed-pitch-mode=
# + sets up the mixed pitch hooks

# #+begin_src emacs-lisp
# (defvar mixed-pitch-modes '(org-mode LaTeX-mode markdown-mode gfm-mode Info-mode)
#   "Modes that `mixed-pitch-mode' should be enabled in, but only after UI initialisation.")
# (defun init-mixed-pitch-h ()
#   "Hook `mixed-pitch-mode' into each mode in `mixed-pitch-modes'.
# Also immediately enables `mixed-pitch-modes' if currently in one of the modes."
#   (when (memq major-mode mixed-pitch-modes)
#     (mixed-pitch-mode 1))
#   (dolist (hook mixed-pitch-modes)
#     (add-hook (intern (concat (symbol-name hook) "-hook")) #'mixed-pitch-mode)))
# (add-hook 'doom-init-ui-hook #'init-mixed-pitch-h)
# #+end_src

# As mixed pitch uses the variable =mixed-pitch-face=, we can create a new function
# to apply mixed pitch with a serif face instead of the default (see the
# subsequent face definition). This was created for writeroom mode.

# #+begin_src emacs-lisp
# (autoload #'mixed-pitch-serif-mode "mixed-pitch"
#   "Change the default face of the current buffer to a serifed variable pitch, while keeping some faces fixed pitch." t)

# (setq! variable-pitch-serif-font (font-spec :family "Alegreya" :size 27))

# (after! mixed-pitch
#   (setq mixed-pitch-set-height t)
#   (set-face-attribute 'variable-pitch-serif nil :font variable-pitch-serif-font)
#   (defun mixed-pitch-serif-mode (&optional arg)
#     "Change the default face of the current buffer to a serifed variable pitch, while keeping some faces fixed pitch."
#     (interactive)
#     (let ((mixed-pitch-face 'variable-pitch-serif))
#       (mixed-pitch-mode (or arg 'toggle)))))
# #+end_src

# Now, as Harfbuzz is currently used in Emacs, we'll be missing out on the
# following Alegreya ligatures:
# #+begin_center
# ff /ff/ ffi /ffi/ ffj /ffj/ ffl /ffl/
# fft /fft/ fi /fi/ fj /fj/ ft /ft/
# Th /Th/
# #+end_center

# Thankfully, it isn't to hard to add these to the ~composition-function-table~.
# #+begin_src emacs-lisp
# (set-char-table-range composition-function-table ?f '(["\\(?:ff?[fijlt]\\)" 0 font-shape-gstring]))
# (set-char-table-range composition-function-table ?T '(["\\(?:Th\\)" 0 font-shape-gstring]))
# #+end_src

# **** Variable pitch serif font

# #+call: confpkg()

# It would be nice if we were able to make use of a serif version of the
# =variable-pitch= face. Since this doesn't already exist, let's create it.

# #+begin_src emacs-lisp
# (defface variable-pitch-serif
#     '((t (:family "serif")))
#     "A variable-pitch face with serifs."
#     :group 'basic-faces)
# #+end_src

# For ease of use, let's also set up an easy way of setting the ~:font~ attribute.

# #+begin_src emacs-lisp
# (defcustom variable-pitch-serif-font (font-spec :family "serif")
#   "The font face used for `variable-pitch-serif'."
#   :group 'basic-faces
#   :set (lambda (symbol value)
#          (set-face-attribute 'variable-pitch-serif nil :font value)
#          (set-default-toplevel-value symbol value)))
# #+end_src

# *** Marginalia

# #+call: confpkg("!Pkg Marginalia")

# #+begin_quote
# Part of the =:completion vertico= module.
# #+end_quote

# Marginalia is nice, but the file metadata annotations are a little too plain.
# Specifically, I have these gripes
# + File attributes would be nicer if coloured
# + I don't care about the user/group information if the user/group is me
# + When a file time is recent, a relative age (e.g. =2h ago=) is more useful than
#   the date
# + An indication of file fatness would be nice

# Thanks to the ~marginalia-annotator-registry~, we don't have to advise, we can
# just add a new =file= annotator.

# Another small thing is the face used for docstrings. At the moment it's =(italic
# shadow)=, but I don't like that.

# #+begin_src emacs-lisp
# (after! marginalia
#   (setq marginalia-censor-variables nil)

#   (defadvice! +marginalia--anotate-local-file-colorful (cand)
#     "Just a more colourful version of `marginalia--anotate-local-file'."
#     :override #'marginalia--annotate-local-file
#     (when-let (attrs (file-attributes (substitute-in-file-name
#                                        (marginalia--full-candidate cand))
#                                       'integer))
#       (marginalia--fields
#        ((marginalia--file-owner attrs)
#         :width 12 :face 'marginalia-file-owner)
#        ((marginalia--file-modes attrs))
#        ((+marginalia-file-size-colorful (file-attribute-size attrs))
#         :width 7)
#        ((+marginalia--time-colorful (file-attribute-modification-time attrs))
#         :width 12))))

#   (defun +marginalia--time-colorful (time)
#     (let* ((seconds (float-time (time-subtract (current-time) time)))
#            (color (doom-blend
#                    (face-attribute 'marginalia-date :foreground nil t)
#                    (face-attribute 'marginalia-documentation :foreground nil t)
#                    (/ 1.0 (log (+ 3 (/ (+ 1 seconds) 345600.0)))))))
#       ;; 1 - log(3 + 1/(days + 1)) % grey
#       (propertize (marginalia--time time) 'face (list :foreground color))))

#   (defun +marginalia-file-size-colorful (size)
#     (let* ((size-index (/ (log10 (+ 1 size)) 7.0))
#            (color (if (< size-index 10000000) ; 10m
#                       (doom-blend 'orange 'green size-index)
#                     (doom-blend 'red 'orange (- size-index 1)))))
#       (propertize (file-size-human-readable size) 'face (list :foreground color)))))
# #+end_src

# *** Centaur Tabs

# #+call: confpkg("!Pkg Centaur Tabs")

# #+begin_quote
# From the =:ui tabs= module.
# #+end_quote

# We want to make the tabs a nice, comfy size (~36~), with icons. The modifier
# marker is nice, but the particular default Unicode one causes a lag spike, so
# let's just switch to an ~o~, which still looks decent but doesn't cause any
# issues.
# An 'active-bar' is nice, so let's have one of those. If we have it ~under~ needs us to
# turn on ~x-underline-at-decent~ though. For some reason this didn't seem to work
# inside the src_elisp{(after! ... )} block ¯\_(ツ)_/¯.
# Then let's change the font to a sans serif, but the default one doesn't fit too
# well somehow, so let's switch to 'P22 Underground Book'; it looks much nicer.

# #+begin_src emacs-lisp
# (after! centaur-tabs
#   (centaur-tabs-mode -1)
#   (setq centaur-tabs-height 36
#         centaur-tabs-set-icons t
#         centaur-tabs-modified-marker "o"
#         centaur-tabs-close-button "×"
#         centaur-tabs-set-bar 'above
#         centaur-tabs-gray-out-icons 'buffer)
#   (centaur-tabs-change-fonts "P22 Underground Book" 160))
# ;; (setq x-underline-at-descent-line t)
# #+end_src

# *** Nerd Icons

# #+call: confpkg("!Pkg Nerd Icons")

# #+begin_quote
# From the =:core packages= module.
# #+end_quote

# =nerd-icons= does a generally great job giving file names icons. One minor
# niggle I have is that when /I/ open a =.m= file, it's much more likely to be Matlab
# than Objective-C. As such, it'll be switching the icon associated with =.m=.

# #+begin_src emacs-lisp
# (after! nerd-icons
#   (setcdr (assoc "m" nerd-icons-extension-icon-alist)
#           (cdr (assoc "matlab" nerd-icons-extension-icon-alist))))
# #+end_src

# *** Prettier page breaks

# #+call: confpkg("!Pkg page break lines")

# In some files, =^L= appears as a page break character. This isn't that visually
# appealing, and Steve Purcell has been nice enough to make a package to display
# these as horizontal rules.
# #+begin_src emacs-lisp :tangle packages.el
# (package! page-break-lines :recipe (:host github :repo "purcell/page-break-lines")
#   :pin "79eca86e0634ac68af862e15c8a236c37f446dcd")
# #+end_src

# #+begin_src emacs-lisp
# (use-package! page-break-lines
#   :commands page-break-lines-mode
#   :init
#   (autoload 'turn-on-page-break-lines-mode "page-break-lines")
#   :config
#   (setq page-break-lines-max-width fill-column)
#   (map! :prefix "g"
#         :desc "Prev page break" :nv "[" #'backward-page
#         :desc "Next page break" :nv "]" #'forward-page))
# #+end_src

# *** Writeroom

# #+call: confpkg("Writeroom")

# #+begin_quote
# From the =:ui zen= module.
# #+end_quote

# For starters, I think Doom is a bit over-zealous when zooming in
# #+begin_src emacs-lisp
# (setq +zen-text-scale 0.8)
# #+end_src

# Then, when using Org it would be nice to make a number of other aesthetic
# tweaks. Namely:
# + Use a serifed variable-pitch font
# + Hiding headline leading stars
# + Using fleurons as headline bullets
# + Hiding line numbers
# + Removing outline indentation
# + Centring the text

# #+begin_src emacs-lisp
# (defvar +zen-serif-p t
#   "Whether to use a serifed font with `mixed-pitch-mode'.")
# (defvar +zen-org-starhide t
#   "The value `org-modern-hide-stars' is set to.")

# (after! writeroom-mode
#   (defvar-local +zen--original-org-indent-mode-p nil)
#   (defvar-local +zen--original-mixed-pitch-mode-p nil)
#   (defun +zen-enable-mixed-pitch-mode-h ()
#     "Enable `mixed-pitch-mode' when in `+zen-mixed-pitch-modes'."
#     (when (apply #'derived-mode-p +zen-mixed-pitch-modes)
#       (if writeroom-mode
#           (progn
#             (setq +zen--original-mixed-pitch-mode-p mixed-pitch-mode)
#             (funcall (if +zen-serif-p #'mixed-pitch-serif-mode #'mixed-pitch-mode) 1))
#         (funcall #'mixed-pitch-mode (if +zen--original-mixed-pitch-mode-p 1 -1)))))
#   (defun +zen-prose-org-h ()
#     "Reformat the current Org buffer appearance for prose."
#     (when (eq major-mode 'org-mode)
#       (setq display-line-numbers nil
#             visual-fill-column-width 60
#             org-adapt-indentation nil)
#       (when (featurep 'org-modern)
#         (setq-local org-modern-star '("🙘" "🙙" "🙚" "🙛")
#                     ;; org-modern-star '("🙐" "🙑" "🙒" "🙓" "🙔" "🙕" "🙖" "🙗")
#                     org-modern-hide-stars +zen-org-starhide)
#         (org-modern-mode -1)
#         (org-modern-mode 1))
#       (setq
#        +zen--original-org-indent-mode-p org-indent-mode)
#       (org-indent-mode -1)))
#   (defun +zen-nonprose-org-h ()
#     "Reverse the effect of `+zen-prose-org'."
#     (when (eq major-mode 'org-mode)
#       (when (bound-and-true-p org-modern-mode)
#         (org-modern-mode -1)
#         (org-modern-mode 1))
#       (when +zen--original-org-indent-mode-p (org-indent-mode 1))))
#   (pushnew! writeroom--local-variables
#             'display-line-numbers
#             'visual-fill-column-width
#             'org-adapt-indentation
#             'org-modern-mode
#             'org-modern-star
#             'org-modern-hide-stars)
#   (add-hook 'writeroom-mode-enable-hook #'+zen-prose-org-h)
#   (add-hook 'writeroom-mode-disable-hook #'+zen-nonprose-org-h))
# #+end_src

# #+attr_html: :class invertible :alt Writeroom applied to an Org file
# [[https://tecosaur.com/lfs/emacs-config/screenshots/writeroom-and-org.png]]

# *** Treemacs

# #+call: confpkg("!Pkg treemacs")

# #+begin_quote
# From the =:ui treemacs= module.
# #+end_quote

# Quite often there are superfluous files I'm not that interested in. There's no
# good reason for them to take up space. Let's add a mechanism to ignore them.
# #+begin_src emacs-lisp
# (after! treemacs
#   (defvar treemacs-file-ignore-extensions '()
#     "File extension which `treemacs-ignore-filter' will ensure are ignored")
#   (defvar treemacs-file-ignore-globs '()
#     "Globs which will are transformed to `treemacs-file-ignore-regexps' which `treemacs-ignore-filter' will ensure are ignored")
#   (defvar treemacs-file-ignore-regexps '()
#     "RegExps to be tested to ignore files, generated from `treeemacs-file-ignore-globs'")
#   (defun treemacs-file-ignore-generate-regexps ()
#     "Generate `treemacs-file-ignore-regexps' from `treemacs-file-ignore-globs'"
#     (setq treemacs-file-ignore-regexps (mapcar 'dired-glob-regexp treemacs-file-ignore-globs)))
#   (if (equal treemacs-file-ignore-globs '()) nil (treemacs-file-ignore-generate-regexps))
#   (defun treemacs-ignore-filter (file full-path)
#     "Ignore files specified by `treemacs-file-ignore-extensions', and `treemacs-file-ignore-regexps'"
#     (or (member (file-name-extension file) treemacs-file-ignore-extensions)
#         (let ((ignore-file nil))
#           (dolist (regexp treemacs-file-ignore-regexps ignore-file)
#             (setq ignore-file (or ignore-file (if (string-match-p regexp full-path) t nil)))))))
#   (add-to-list 'treemacs-ignored-file-predicates #'treemacs-ignore-filter))
# #+end_src

# Now, we just identify the files in question.
# #+begin_src emacs-lisp
# (setq treemacs-file-ignore-extensions
#       '(;; LaTeX
#         "aux"
#         "ptc"
#         "fdb_latexmk"
#         "fls"
#         "synctex.gz"
#         "toc"
#         ;; LaTeX - glossary
#         "glg"
#         "glo"
#         "gls"
#         "glsdefs"
#         "ist"
#         "acn"
#         "acr"
#         "alg"
#         ;; LaTeX - pgfplots
#         "mw"
#         ;; LaTeX - pdfx
#         "pdfa.xmpi"
#         ))
# (setq treemacs-file-ignore-globs
#       '(;; LaTeX
#         "*/_minted-*"
#         ;; AucTeX
#         "*/.auctex-auto"
#         "*/_region_.log"
#         "*/_region_.tex"))
# #+end_src

** File types
*** Systemd

#+call: confpkg("!Pkg Systemd")

For editing systemd unit files
#+begin_src emacs-lisp :tangle packages.el
(package! systemd :pin "b6ae63a236605b1c5e1069f7d3afe06ae32a7bae")
#+end_src

#+begin_src emacs-lisp
(use-package! systemd
  :defer t)
#+end_src

* Custom Workflow
** Type Break

# #+call: confpkg("!Pkg type-break")
# #+begin_src emacs-lisp
# (use-package! type-break
#   ;; :hook ((org-pomodoro-killed . type-break-mode)
#   ;;        (org-pomodoro-break-finished . type-break-mode)
#   ;;        (org-pomodoro-started . (lambda () (type-break-mode -1)))
#   ;;        (after-init . type-break-mode))
#   :init
#   (defun type-break-demo-agenda ()
#     "Display the Org Agenda in read-only mode. Cease the demo as soon as a key is pressed."
#     (let ((buffer-name "*Typing Break Org Agenda*")
#           lines)
#       (condition-case ()
#           (progn
#             ;; (org-agenda-list)
#             ;; (org-agenda nil "n")
#             (org-gtd-engage)
#             (setq buffer-name (buffer-name))
#             ;; Set the buffer to read-only
#             (with-current-buffer buffer-name
#               (read-only-mode 1))
#             ;; Message to be displayed at the bottom
#             (let ((msg (if type-break-terse-messages
#                            ""
#                          "Press any key to resume from typing break")))
#               ;; Loop until key is pressed
#               (while (not (input-pending-p))
#                 (sit-for 60))
#               ;; Clean up after key is pressed
#               (read-event)
#               (type-break-catch-up-event)
#               (kill-buffer buffer-name)))
#         (quit
#          (and (get-buffer buffer-name)
#               (kill-buffer buffer-name))))))

#   :config
#   ;; Setting interval of that of a pomodoro session
#   (setq type-break-interval (* 25 60) ;; 25 mins
#         type-break-good-rest-interval (* 9 60) ;; 9 mins
#         type-break-good-break-interval (* 5 60) ;; 5 mins
#         type-break-query-mode t
#         type-break-keystroke-threshold '(nil . 2625)
#         type-break-demo-boring-stats t
#         type-break-demo-functions '(type-break-demo-agenda)))
# #+end_src

** Org pomodoro

#+call: confpkg("!Pkg org-pomodoro", after="org")

#+begin_src emacs-lisp
(use-package! org-pomodoro
  :after org
  :bind (("<f12>" . org-pomodoro))
  ;; :hook ((org-pomodoro-started . gopar/load-window-config-and-close-work-agenda)
  ;;        (org-pomodoro-finished . gopar/save-window-config-and-show-work-agenda))
  :config
  (setq org-pomodoro-manual-break t
        org-pomodoro-short-break-length 30
        org-pomodoro-long-break-length 30
        org-pomodoro-length 90)
  :init
  (defun gopar/home-pomodoro ()
    (interactive)
    (setq org-pomodoro-length 25
          org-pomodoro-short-break-length 5))

  (defun gopar/work-pomodoro ()
    (interactive)
    (setq org-pomodoro-length 90
          org-pomodoro-short-break-length 30))

  (defun gopar/save-window-config-and-show-work-agenda ()
    (interactive)
    (window-configuration-to-register ?`)
    (delete-other-windows)
    (org-save-all-org-buffers)
    ;; (org-agenda nil "n"))
    (org-gtd-engage))

  (defun gopar/load-window-config-and-close-work-agenda ()
    (interactive)
    (org-save-all-org-buffers)
    (jump-to-register ?`)))
#+end_src

** org-noter

#+call: confpkg("!Pkg org-noter", after="org")

# Here I'm using my forked version of the package. There I merged the
# org-roam-integration branch.

# #+begin_src emacs-lisp :tangle packages.el
# (package! org-noter :recipe (:host github :repo "org-noter/org-noter"))
# (unpin! org-noter)
# #+end_src

#+begin_src emacs-lisp
(use-package! org-noter
  :config
  (org-noter-enable-org-roam-integration))
#+end_src

**  citar-org-roam

#+call: confpkg("!Pkg citar-org-roam")

#+begin_src emacs-lisp :tangle packages.el
(package! citar-org-roam :recipe (:host github :repo "emacs-citar/citar-org-roam" :files ("*.el")))
#+end_src

#+begin_src emacs-lisp
(use-package! citar-org-roam
  :after (citar org-roam)
  :config
  (citar-org-roam-mode)
  (setq citar-org-roam-capture-template-key "l"))
#+end_src

**  activity watch mode

#+call: confpkg("!Pkg activity-watch-mode")
#+begin_src emacs-lisp :tangle packages.el
(package! activity-watch-mode)
#+end_src

** org-clock-convenience
#+call: confpkg("!Pkg org-clock-convenience", after="org")

#+begin_src emacs-lisp :tangle packages.el
(package! org-clock-convenience)
#+end_src

#+begin_src emacs-lisp
(use-package! org-clock-convenience
   :after org
   :config
   (map! :map org-agenda-mode-map
         "<S-up>" #'org-clock-convenience-timestamp-up
         "<S-down>" #'org-clock-convenience-timestamp-down
         "o" #'org-clock-convenience-fill-gap
         "e" #'org-clock-convenience-fill-gap-both))
#+end_src

** org-clock-today
#+call: confpkg("!Pkg org-clock-today", after="org")

#+begin_src emacs-lisp :tangle packages.el
(package! org-clock-today)
#+end_src

** GTD
#+call: confpkg("!Pkg org-gtd", after="org")

#+begin_src emacs-lisp :tangle packages.el
(package! org-gtd)
#+end_src

#+begin_src emacs-lisp
(use-package! org-gtd
  :after org
  :init
  (setq org-gtd-update-ack "3.0.0")
  :config
  (org-edna-mode)
  (setq org-edna-use-inheritance t
        org-gtd-engage-prefix-width 16
        org-gtd-directory "~/org/gtd"
        org-gtd-organize-hooks '(org-set-tags-command))

  (map! :prefix ("C-c d" . "org-gtd")
        :desc "Capture"        "c"  #'org-gtd-capture
        :desc "Engage"         "e"  #'org-gtd-engage
        :desc "Process inbox"  "p"  #'org-gtd-process-inbox
        :desc "Show all next"  "n"  #'org-gtd-show-all-next
        :desc "Stuck projects" "s"  #'org-gtd-review-stuck-projects)
  (map! :map org-gtd-clarify-map
        :desc "Organize this item" "C-c c" #'org-gtd-organize))
#+end_src
